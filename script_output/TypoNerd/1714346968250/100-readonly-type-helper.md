---
title: Output of TypoNerd against 100-readonly-type-helper.md
description: Generating proposed edits against a source text file using the TypoNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
In this exercise, we have a `handleSearchParams` function. This function consumes a search object that consists of several potential search parameters. These parameters include:

```ts
type SearchParams = {
  q?: string;
  page?: number;
  pageSize?: number;
  sort?: string;
  order?: "asc" | "desc";
};
```

All these parameters are optional, but they should be read-only. This is because they come directly from the URL and serve as the source of truth. Therefore, we shouldn't allow modifications to these parameters. 

As seen in the `handleSearchParams` function, if we try to modify these parameters, we should get errors telling us that we should not be able to modify these read-only parameters:

```ts
const handleSearchParams = (search: SearchParams) => {
  // Do something with the search params

  // @ts-expect-error Should not be able to modify readonly
  search.q = "test";

  // @ts-expect-error Should not be able to modify readonly
  search.page = 1;

  // @ts-expect-error Should not be able to modify readonly
  search.pageSize = 10;

  // @ts-expect-error Should not be able to modify readonly
  search.sort = "name";

  // @ts-expect-error Should not be able to modify readonly
  search.order = "asc";
};
```

However, because the search parameters are not read-only, we do not get any errors. This is because TypeScript infers the `search` parameter as a mutable object. Therefore, it allows us to modify the properties of the `search` object.

## Challenge

Your task is to make sure the potential search parameters are read-only.

An obvious way to enforce the read-only status is to append the `readonly` keyword on every parameter individually. However, a more efficient approach involves using a type helper. This helper can be applied to the `SearchParams` type, making all of its properties read-only at once.

Find and properly implement this type helper to mark every property in `SearchParams` as read-only.

# Resolution
TypeScript's `Readonly` type helper ensures that all object properties are read-only:

```typescript
Readonly<YourObjectHere>
```

If you try to modify a read-only property, you will encounter errors. However, this doesn't alter the characteristics of the properties themselves - they continue to remain optional.

With the `SearchParams` object, the properties will still be optional, but the `Readonly` type helper will ensure that they cannot be modified.

```typescript
type SearchParams = {
  q?: string;
  page?: number;
  pageSize?: number;
  sort?: string;
  order?: "asc" | "desc";
};

const handleSearchParams = (search: Readonly<SearchParams>) => {
  // Do something with the search params

  // @ts-expect-error Should not be able to modify readonly
  search.q = "test";

  // @ts-expect-error Should not be able to modify readonly
  search.page = 1;

  // @ts-expect-error Should not be able to modify readonly
  search.pageSize = 10;

  // @ts-expect-error Should not be able to modify readonly
  search.sort = "name";

  // @ts-expect-error Should not be able to modify readonly
  search.order = "asc";
};
```

One peculiarity of `Readonly` is that, much like many of TypeScript's type helpers, it only operates on the first level. It won't make properties read-only recursively.

It's also worth noting that the `Readonly` utility works like `Object.freeze`, behaving as though the object is frozen and can't be modified at the type level, but it doesn't influence the object at runtime.

### Operation Results:
This operation generated results by running the TypoNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{}
```

#### Anthropic:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'read-only status is to append the `readonly` keyword on every parameter individually',
      proposed_replacement: 'read-only status is to prepend the `readonly` keyword to every parameter individually',
      reasoning: 'The `readonly` keyword should be prepended (placed before) each parameter, not appended (placed after).',
      confidence: 0.95
    }
  ]
}
```

#### Gemini:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'An obvious way to enforce the read-only status is to append the `readonly` keyword on every parameter individually. However, a more efficient approach involves using a type helper. This helper can be applied to the `SearchParams` type, making all of its properties read-only at once.',
      proposed_replacement: 'An obvious way to enforce the read-only status is to append the `readonly` keyword to every parameter individually. However, a more efficient approach involves using a type helper. This helper can be applied to the `SearchParams` type, making all of its properties read-only at once.',
      reasoning: 'The preposition "to" is missing before "every".',
      confidence: 0.9
    }
  ]
}
```