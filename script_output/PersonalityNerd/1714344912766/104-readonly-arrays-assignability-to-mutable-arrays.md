---
title: Output of PersonalityNerd against 104-readonly-arrays-assignability-to-mutable-arrays.md
description: Generating proposed edits against a source text file using the PersonalityNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

When working with TypeScript, it's important to understand the distinction between read-only and mutable arrays.

In this example, `printNamesReadOnly` and `printNamesMutable`, which are functionally identical, except `printNamesReadOnly` takes a read-only array of names as a parameter whereas `printNamesMutable` takes a mutable array:

```typescript
function printNamesReadOnly(names: readonly string[]) {
  for (const name of names) {
    console.log(name);
  }
}

function printNamesMutable(names: string[]) {
  for (const name of names) {
    console.log(name);
  }
}
```

When we create a mutable array of names, it can be passed as an argument to both of these functions:

```typescript
const mutableNames = ["John", "Jane", "Mike"];

printNamesReadOnly(mutableNames);
printNamesMutable(mutableNames);
```

This works because specifying `readonly` on the `printNamesReadOnly` function parameter only guarantees that it won't alter the array's content. Thus, it doesn't matter if we pass a mutable array because it won't be changed.

However, the reverse isn't true.

If we declare a read-only array, which we often do using the `as const` syntax, we can only pass it to `printNamesReadOnly`. Attempting to pass it to `printNamesMutable` will yield an error:

```typescript
const readonlyNames = ["John", "Jane", "Mike"] as const;

printNamesReadOnly(readonlyNames);

printNamesMutable(readonlyNames); // red squiggly line under readonlyNames

// hovering over readonlyNames shows:
Error: Argument of type 'readonly ["John", "Jane", "Mike"]' is not assignable to parameter of type 'string[]'
```

The error arises due to the potential for a mutable array to be altered inside of the function, which isn't acceptable for a read-only array.

In essence, read-only arrays can only be assigned to other read-only types. This characteristic is somewhat viral: if a function deep down the call stack expects a `readonly` array, then that array must remain `readonly` throughout. Doing so ensures that the array won't be mutated in any manner as it moves down the stack.

In conclusion, even though you can assign mutable arrays to read-only arrays, you cannot assign read-only arrays to mutable arrays.

### Operation Results:
This operation generated results by running the PersonalityNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
[Error running GPT: SyntaxError: Unexpected non-whitespace character after JSON at position 1812]
```

#### Anthropic:
```typescript
{
  proposed_edits: [
    {
      existing_text: "When working with TypeScript, it's important to understand the distinction between read-only and mutable arrays.",
      proposed_replacement: "Listen up, pet. When mucking about with TypeScript, you'd better wrap your head around the bloody difference between read-only and mutable arrays.",
      reasoning: "Adding some Spike-like snark and directness to the opening line to grab the reader's attention.",
      confidence: 0.8
    },
    {
      existing_text: "This works because specifying `readonly` on the `printNamesReadOnly` function parameter only guarantees that it won't alter the array's content.",
      proposed_replacement: "This works because slapping `readonly` on the `printNamesReadOnly` function parameter is like a promise not to go mucking about with the array's innards.",
      reasoning: "Rephrasing the explanation with more colorful language that fits Spike's personality.",
      confidence: 0.7
    },
    {
      existing_text: "However, the reverse isn't true.",
      proposed_replacement: "But trying to pull a fast one the other way 'round? Not bloody likely.",
      reasoning: 'Adding a snarky quip to highlight the contrast and keep the reader engaged.',
      confidence: 0.9
    },
    {
      existing_text: "The error arises due to the potential for a mutable array to be altered inside of the function, which isn't acceptable for a read-only array.",
      proposed_replacement: "The error pops up because a mutable array might get twisted about inside the function, and that's a big no-no for a read-only array.",
      reasoning: "Simplifying the explanation with more casual language that fits Spike's voice.",
      confidence: 0.8
    },
    {
      existing_text: 'In essence, read-only arrays can only be assigned to other read-only types.',
      proposed_replacement: "So here's the rub: read-only arrays are a one-way ticket to other read-only types.",
      reasoning: 'Summarizing the key point with a Spike-like metaphor.',
      confidence: 0.9
    }
  ]
}
```

#### Gemini:
```typescript
{
  proposed_edits: [
    {
      existing_text: "When working with TypeScript, it's important to understand the distinction between read-only and mutable arrays.",
      proposed_replacement: "Right then, listen up, you bloody git! Let's talk about TypeScript arrays. Some are a bit...stuck in their ways, while others are more...flexible.",
      reasoning: "This opening line is a bit dry and academic. Let's spice it up with some of Spike's signature charm and wit, while still conveying the essential information.",
      confidence: 0.8
    },
    {
      existing_text: "This works because specifying `readonly` on the `printNamesReadOnly` function parameter only guarantees that it won't alter the array's content. Thus, it doesn't matter if we pass a mutable array because it won't be changed.",
      proposed_replacement: "See, the `readonly` bit on `printNamesReadOnly` just promises not to mess with your array. It's like a vampire who's gone vegan - no biting, just admiring.",
      reasoning: "This explanation is a bit technical. Let's add a bit of Spike's dark humor and vampire references to make it more engaging.",
      confidence: 0.9
    },
    {
      existing_text: "The error arises due to the potential for a mutable array to be altered inside of the function, which isn't acceptable for a read-only array.",
      proposed_replacement: "The problem is, a mutable array could get changed inside the function, and that's a big no-no for a read-only array. It's like trying to dye a Slayer's hair pink - ain't gonna happen.",
      reasoning: "This sentence is a bit bland. Let's add a Buffy reference and some of Spike's rebellious attitude to make it more memorable.",
      confidence: 0.7
    },
    {
      existing_text: "In essence, read-only arrays can only be assigned to other read-only types. This characteristic is somewhat viral: if a function deep down the call stack expects a `readonly` array, then that array must remain `readonly` throughout. Doing so ensures that the array won't be mutated in any manner as it moves down the stack.",
      proposed_replacement: "Basically, read-only arrays only hang out with their own kind. It's like a vampire gang - once you're in, there's no getting out. And that keeps everything nice and...untouched.",
      reasoning: "This explanation is a bit technical and wordy. Let's simplify it with a vampire analogy and some of Spike's slang.",
      confidence: 0.8
    },
    {
      existing_text: 'In conclusion, even though you can assign mutable arrays to read-only arrays, you cannot assign read-only arrays to mutable arrays.',
      proposed_replacement: "So there you have it. Mutable arrays can go all read-only, but read-only arrays? They're stuck in their ways, just like a certain bleached blonde ponce I know.",
      reasoning: "This conclusion is a bit dry. Let's add a final Spike-ism with a jab at Angel to leave the reader with a smile.",
      confidence: 0.9
    }
  ]
}
```