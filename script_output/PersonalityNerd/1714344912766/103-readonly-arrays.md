---
title: Output of PersonalityNerd against 103-readonly-arrays.md
description: Generating proposed edits against a source text file using the PersonalityNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
In this exercise, you'll be dealing with a function called `printNames`. This function accepts an array of `names` and prints each name to the console.

However, we want to add a special restriction to this function: it shouldn't be possible to mutate the array it receives. In other words, operations such as adding or changing an element in the array shouldn't be allowed:

```typescript
function printNames(names: string[]) {
  for (const name of names) {
    console.log(name);
  }

  // @ts-expect-error // red squiggly line
  names.push("John");

  // @ts-expect-error // red squiggly line
  names[0] = "Billy";
}
```

However, in the current implementation the `@ts-expect-error` directives show us that it's possible to mutate the array.

## Challenge

Your task is to determine what type should be assigned to the `names` parameter to ensure that the array cannot be mutated. There are two ways to solve this problem.

# Resolution
There are a couple of strategies for handling read-only arrays in TypeScript. Both are functionally identical, and your choice of which to use will ultimately come down to personal preference.

## Solution 1: Add the `readonly` Keyword

The first approach solution is to add the `readonly` keyword before the `string[]` array. It applies to the entire `string[]` array, converting it into a read-only array:

```typescript
function printNames(names: readonly string[]) {
  ...
}
```

With this setup, you can't call `.push()` or modify elements in the array. However, methods like `map()` and `reduce()` remain accessible since these create a copy of the array, and do not mutate the original.

## Solution 2: Use the `ReadonlyArray` Type Helper

Alternatively, TypeScript offers a type helper called `ReadonlyArray` that functions in the same way:

```typescript
function printNames(names: ReadonlyArray<string>) {
  ...
}
```

Regardless of which of these two methods you use, TypeScript will still display `readonly string[]` when hovering over the `names` parameter:

```typescript
// hovering over `names` shows:
(parameter) names: readonly string[]
```

No matter which syntax you prefer, both approaches are functionally identical. If you feel the need to choose one, it might be better to choose the `readonly string[]` syntax for consistency. Whichever you choose, remember they're essentially the same under the hood.

### Operation Results:
This operation generated results by running the PersonalityNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
[Error running GPT: SyntaxError: Expected ',' or '}' after property value in JSON at position 1989]
```

#### Anthropic:
```typescript
{
  proposed_edits: [
    {
      existing_text: "In this exercise, you'll be dealing with a function called `printNames`.",
      proposed_replacement: "In this little game of code, you'll be tangling with a function called `printNames`.",
      reasoning: "Adding a bit of Spike's playful and irreverent tone to the introduction.",
      confidence: 0.8
    },
    {
      existing_text: "However, we want to add a special restriction to this function: it shouldn't be possible to mutate the array it receives.",
      proposed_replacement: "But here's the kicker: we want to slap a special restriction on this function. No mucking about with the array it gets, got it?",
      reasoning: 'Rephrasing the restriction in a more casual, Spike-like way.',
      confidence: 0.9
    },
    {
      existing_text: 'Your task is to determine what type should be assigned to the `names` parameter to ensure that the array cannot be mutated.',
      proposed_replacement: "So here's your mission, if you choose to accept it: figure out what bloody type to give the `names` parameter so nobody can mess with the array.",
      reasoning: "Presenting the challenge with some of Spike's attitude and slang.",
      confidence: 0.85
    },
    {
      existing_text: 'There are a couple of strategies for handling read-only arrays in TypeScript.',
      proposed_replacement: "Now, there are a couple of tricks up TypeScript's sleeve for dealing with these read-only arrays.",
      reasoning: 'Using more colorful language to describe the solution strategies.',
      confidence: 0.7
    },
    {
      existing_text: 'No matter which syntax you prefer, both approaches are functionally identical.',
      proposed_replacement: "At the end of the day, it doesn't matter which way you slice it. Both of these approaches do the same bloody thing.",
      reasoning: "Summarizing the equivalence of the solutions in Spike's blunt manner.",
      confidence: 0.9
    }
  ]
}
```

#### Gemini:
```typescript
{
  proposed_edits: [
    {
      existing_text: "In this exercise, you'll be dealing with a function called `printNames`. This function accepts an array of `names` and prints each name to the console.",
      proposed_replacement: "Right then, listen up. We've got this function, see, called `printNames`. It takes a bunch of names, like a bloody phone book, and spits 'em out one by one.",
      reasoning: "This is a more engaging and 'spikey' way to introduce the function and its purpose.",
      confidence: 0.8
    },
    {
      existing_text: "However, we want to add a special restriction to this function: it shouldn't be possible to mutate the array it receives. In other words, operations such as adding or changing an element in the array shouldn't be allowed:",
      proposed_replacement: "Now, here's the rub. We don't want anyone messing with this list of names. No adding, no changing, no funny business. It's like a museum exhibit, look but don't touch.",
      reasoning: "This adds a bit of Spike's signature snark and clarifies the restriction in a more engaging way.",
      confidence: 0.9
    },
    {
      existing_text: 'Your task is to determine what type should be assigned to the `names` parameter to ensure that the array cannot be mutated. There are two ways to solve this problem.',
      proposed_replacement: "So, your mission, should you choose to accept it, is to figure out how to lock down this array. There's more than one way to skin a cat, or in this case, an array.",
      reasoning: "This adds a bit of a challenge and a touch of dark humor, aligning with Spike's personality.",
      confidence: 0.7
    },
    {
      existing_text: 'The first approach solution is to add the `readonly` keyword before the `string[]` array. It applies to the entire `string[]` array, converting it into a read-only array:',
      proposed_replacement: "First up, we can slap a `readonly` on that array like a garlic necklace on a vamp. That'll keep it safe from any unwanted changes.",
      reasoning: "This uses a vampire-related metaphor to explain the concept in a way that aligns with Spike's character.",
      confidence: 0.9
    },
    {
      existing_text: 'Alternatively, TypeScript offers a type helper called `ReadonlyArray` that functions in the same way:',
      proposed_replacement: "Or, if you're feeling fancy, you can use this `ReadonlyArray` thingamajig. It's like the `readonly` keyword's posh cousin, but they both do the same job.",
      reasoning: "This adds a bit of humor and a touch of Spike's casual way of speaking.",
      confidence: 0.8
    },
    {
      existing_text: "No matter which syntax you prefer, both approaches are functionally identical. If you feel the need to choose one, it might be better to choose the `readonly string[]` syntax for consistency. Whichever you choose, remember they're essentially the same under the hood.",
      proposed_replacement: "At the end of the day, it doesn't matter which one you pick. They both do the trick. Just like a stake through the heart, they'll stop that array from changing.",
      reasoning: "This concludes with a dark humor reference that aligns with Spike's character and reinforces the concept of immutability.",
      confidence: 0.9
    }
  ]
}
```