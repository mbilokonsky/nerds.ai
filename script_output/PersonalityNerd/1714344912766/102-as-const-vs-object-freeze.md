---
title: Output of PersonalityNerd against 102-as-const-vs-object-freeze.md
description: Generating proposed edits against a source text file using the PersonalityNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
In our continued exploration of button types, we now have a modified version of `ButtonAttributes` that accepts `cancel` and `confirm` buttons. Each of these buttons exists as an object with a `type` of `ButtonType`. As in the previous exercises, the `ButtonType` remains either `button`, `submit`, or `reset`:

```tsx
type ButtonType = "button" | "submit" | "reset";

type ButtonAttributes = {
  cancel: {
    type: ButtonType;
  };
  confirm: {
    type: ButtonType;
  };
};
```

We call `Object.freeze()` on `buttonAttributes` which effectively locks the object, preventing any property alterations: 

```tsx
const modifyButtons = (attributes: ButtonAttributes) => {};

const buttonAttributes = Object.freeze({
  cancel: {
    type: "button",
  },
  confirm: {
    type: "button",
  },
});

modifyButtons(buttonAttributes); // red squiggly line under buttonAttributes
```

However, there's an error when we call `modifyButtons` with `buttonAttributes`.

## Challenge

Your task is to diagnose why we have an error when using `Object.freeze`, since it seems like it should work like `as const` did.

To solve the issue, you should only modify the `buttonAttributes` code.

# Resolution
In TypeScript, using `Object.freeze` is a common method for creating immutable objects. However, there are some significant differences between `Object.freeze` and `as const`.

When applying `Object.freeze` to the `buttonAttributes` object, we can see that a read-only modifier is being inferred on this object:

```typescript
type ButtonType = "button" | "submit" | "reset";

const buttonAttributes = Object.freeze({
  cancel: {
    type: "button" as ButtonType,
  },
  confirm: {
    type: "button" as ButtonType,
  },
});

// hovering over buttonAttributes shows:
const buttonAttributes: Readonly<{
  cancel: {
    type: "button";
  };
  confirm: {
    type: "button";
  };
}>
```

However, it's only working at the top level of the object. For example, if we add another type at the top level like `type: 'blah'`, the top level property is read-only. If we try to modify this, TypeScript will throw an error: 

```typescript
const buttonAttributes = Object.freeze({
  type: "blah",
  cancel: {
    type: "button" as ButtonType,
  },
  confirm: {
    type: "button" as ButtonType,
  },
});

buttonAttributes.type = "submit"; // red squiggly line under `type`

// Hovering over type shows:
Cannot assign to 'type' because it is a read-only property
```

However, `Object.freeze` doesn't work on nested levels of an object, so we can still modify the `type` property of `cancel` and `confirm`:

```typescript
buttonAttributes.confirm.type = "reset";
```

This behavior is because `Object.freeze` is not recursive; it only works on the top level of the object. Another thing to note about `Object.freeze` is that it runs at runtime, which can make your application slower.

An alternative to `Object.freeze` is using `as const`. When we modify `buttonAttributes` to use `as const` instead of `Object.freeze`, the whole object, including all nested layers, becomes read-only. Moreover, `as const` infers those literals too. 

```typescript
const buttonAttributes = {
  cancel: {
    type: "button" as ButtonType,
  },
  confirm: {
    type: "button" as ButtonType,
  },
} as const;

// Hovering over buttonAttributes shows:
const buttonAttributes: {
  readonly cancel: {
    readonly type: "button";
  };
  readonly confirm: {
    readonly type: "button";
  };
}
```

`As const` does not have any runtime cost and recurses through the object, which makes it preferable over `Object.freeze` unless you need to ensure freezing at runtime specifically. Overall, `as const` provides a more convenient and efficient approach to creating immutable objects in TypeScript than using `Object.freeze`.

### Operation Results:
This operation generated results by running the PersonalityNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'In our continued exploration of button types, we now have a modified version of `ButtonAttributes` that accepts `cancel` and `confirm` buttons.',
      proposed_replacement: "In our relentless quest through the wilds of button types, we've stumbled upon a tweaked beastie called `ButtonAttributes` that plays nice with `cancel` and `confirm` buttons.",
      reasoning: "Adding a bit of adventurous and slightly dramatic flair to match Spike's bold and edgy style.",
      confidence: 0.9
    },
    {
      existing_text: "However, there's an error when we call `modifyButtons` with `buttonAttributes`.",
      proposed_replacement: "However, we've hit a snag when we summon `modifyButtons` with `buttonAttributes`.",
      reasoning: "Using 'hit a snag' and 'summon' adds a touch of dramatic and supernatural flair, fitting for Spike's character.",
      confidence: 0.9
    },
    {
      existing_text: 'Your task is to diagnose why we have an error when using `Object.freeze`, since it seems like it should work like `as const` did.',
      proposed_replacement: "Your mission, should you choose to accept it, is to unravel the mystery behind the error with `Object.freeze`, which, by all accounts, should've behaved like `as const`.",
      reasoning: "Adding a mission-like challenge with a hint of mystery reflects Spike's confrontational and adventurous nature.",
      confidence: 0.9
    },
    {
      existing_text: 'This behavior is because `Object.freeze` is not recursive; it only works on the top level of the object.',
      proposed_replacement: "This little quirk is because `Object.freeze` doesn't dig deep; it's a surface-level spell only.",
      reasoning: "Using 'little quirk' and 'surface-level spell' adds a casual, slightly mystical tone, aligning with Spike's character.",
      confidence: 0.9
    },
    {
      existing_text: 'Overall, `as const` provides a more convenient and efficient approach to creating immutable objects in TypeScript than using `Object.freeze`.',
      proposed_replacement: 'All in all, `as const` is the slicker, quicker way to lock down your objects in TypeScript, leaving `Object.freeze` out in the cold.',
      reasoning: "Using 'slicker, quicker' and a playful pun 'out in the cold' adds a witty and slightly mocking tone, characteristic of Spike.",
      confidence: 0.9
    }
  ]
}
```

#### Anthropic:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'In TypeScript, using `Object.freeze` is a common method for creating immutable objects.',
      proposed_replacement: "In TypeScript, using `Object.freeze` is a bloody common method for creating immutable objects, but it's not all it's cracked up to be.",
      reasoning: "Adding a bit of Spike's snark and skepticism about Object.freeze right from the start.",
      confidence: 0.8
    },
    {
      existing_text: 'However, there are some significant differences between `Object.freeze` and `as const`.',
      proposed_replacement: 'However, there are some bloody significant differences between `Object.freeze` and `as const`. Brace yourself.',
      reasoning: "Injecting more of Spike's personality with colorful language and a warning that important info is coming.",
      confidence: 0.9
    },
    {
      existing_text: 'This behavior is because `Object.freeze` is not recursive; it only works on the top level of the object.',
      proposed_replacement: 'This wonky behavior is because `Object.freeze` is about as deep as a kiddie pool - it only works on the top level of the object. Bloody useless if you ask me.',
      reasoning: 'Explaining the limitation of Object.freeze in a more colorful, opinionated way that Spike might.',
      confidence: 0.85
    },
    {
      existing_text: 'Another thing to note about `Object.freeze` is that it runs at runtime, which can make your application slower.',
      proposed_replacement: 'Oh, and another thing to keep in mind about `Object.freeze` is that it runs at runtime, which can make your application slower than a three-legged poodle. Not ideal, mate.',
      reasoning: 'Adding a humorous Spike-like analogy to warn about the performance cost of Object.freeze.',
      confidence: 0.9
    },
    {
      existing_text: 'Overall, `as const` provides a more convenient and efficient approach to creating immutable objects in TypeScript than using `Object.freeze`.',
      proposed_replacement: "At the end of the day, `as const` is the way to go for creating immutable objects in TypeScript. It's like `Object.freeze`, but without all the bloody downsides. Trust me on this one.",
      reasoning: "Summarizing the recommendation in a confident, opinionated way that reflects Spike's personality.",
      confidence: 0.95
    }
  ]
}
```

#### Gemini:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'In our continued exploration of button types, we now have a modified version of `ButtonAttributes` that accepts `cancel` and `confirm` buttons. Each of these buttons exists as an object with a `type` of `ButtonType`. As in the previous exercises, the `ButtonType` remains either `button`, `submit`, or `reset`:',
      proposed_replacement: "Right then, let's have a look-see at these buttons, shall we? We've got ourselves a right proper `ButtonAttributes` now, one that can handle both `cancel` and `confirm` like a champ. Each of these buttons is an object with a `type` of `ButtonType`, which, as we all know, can be either `button`, `submit`, or `reset`:",
      reasoning: 'Spike would use more casual and playful language, with a bit of British slang.',
      confidence: 0.8
    },
    {
      existing_text: 'We call `Object.freeze()` on `buttonAttributes` which effectively locks the object, preventing any property alterations:',
      proposed_replacement: 'We slap an `Object.freeze()` on `buttonAttributes`, which is like putting a stake through its heart - no more mucking about with its properties.',
      reasoning: 'Spike would use a more aggressive and metaphorical way to describe the effect of `Object.freeze()`.',
      confidence: 0.9
    },
    {
      existing_text: "However, there's an error when we call `modifyButtons` with `buttonAttributes`.",
      proposed_replacement: "But bloody hell, we've got a right mess when we try to use `modifyButtons` with `buttonAttributes`.",
      reasoning: 'Spike would express frustration with the error in a more colorful way.',
      confidence: 0.7
    },
    {
      existing_text: 'Your task is to diagnose why we have an error when using `Object.freeze`, since it seems like it should work like `as const` did.',
      proposed_replacement: 'Your mission, should you choose to accept it, is to figure out why this `Object.freeze` is acting like a right git, when it should be behaving itself like `as const`.',
      reasoning: 'Spike would present the challenge in a more engaging and humorous way.',
      confidence: 0.85
    },
    {
      existing_text: 'To solve the issue, you should only modify the `buttonAttributes` code.',
      proposed_replacement: "And remember, we only want to fiddle with the `buttonAttributes` code. Don't go getting any bright ideas about messing with anything else.",
      reasoning: 'Spike would add a warning in a more playful and threatening way.',
      confidence: 0.9
    },
    {
      existing_text: 'In TypeScript, using `Object.freeze` is a common method for creating immutable objects. However, there are some significant differences between `Object.freeze` and `as const`.',
      proposed_replacement: "Now, listen close. In TypeScript, `Object.freeze` is supposed to make your objects all nice and immutable, like a vampire stuck in a crypt. But it's not quite the same as `as const`, and that's where the trouble starts.",
      reasoning: 'Spike would explain the concept of immutability using a vampire metaphor and emphasize the difference between `Object.freeze` and `as const`.',
      confidence: 0.95
    },
    {
      existing_text: 'When applying `Object.freeze` to the `buttonAttributes` object, we can see that a read-only modifier is being inferred on this object:',
      proposed_replacement: "When we use `Object.freeze` on `buttonAttributes`, it's like putting a padlock on the front door. You can't change the object itself, but the sneaky bugger leaves the back door wide open.",
      reasoning: 'Spike would use a more relatable analogy to explain the effect of `Object.freeze()`.',
      confidence: 0.8
    },
    {
      existing_text: "However, it's only working at the top level of the object. For example, if we add another type at the top level like `type: 'blah'`, the top level property is read-only. If we try to modify this, TypeScript will throw an error:",
      proposed_replacement: "But here's the rub: it only works on the top level. So, if you add something new, like `type: 'blah'`, it's locked up tight. Try to change it, and TypeScript will bite your head off.",
      reasoning: 'Spike would explain the limitation of `Object.freeze()` in a more dramatic and humorous way.',
      confidence: 0.85
    },
    {
      existing_text: "However, `Object.freeze` doesn't work on nested levels of an object, so we can still modify the `type` property of `cancel` and `confirm`:",
      proposed_replacement: "But the blighter doesn't work on the stuff inside. So, you can still mess with the `type` property of `cancel` and `confirm` like a right vandal.",
      reasoning: 'Spike would express the issue with nested levels in a more critical and engaging way.',
      confidence: 0.9
    },
    {
      existing_text: 'This behavior is because `Object.freeze` is not recursive; it only works on the top level of the object. Another thing to note about `Object.freeze` is that it runs at runtime, which can make your application slower.',
      proposed_replacement: "That's because `Object.freeze` is a lazy sod; it only does the bare minimum. And to top it off, it does its work at runtime, which can slow your application down like a stake through the heart.",
      reasoning: 'Spike would criticize the limitations of `Object.freeze()` in a more humorous and metaphorical way.',
      confidence: 0.95
    },
    {
      existing_text: 'An alternative to `Object.freeze` is using `as const`. When we modify `buttonAttributes` to use `as const` instead of `Object.freeze`, the whole object, including all nested layers, becomes read-only. Moreover, `as const` infers those literals too.',
      proposed_replacement: "Now, if you want to do things proper, use `as const`. It's like a magic spell that makes the whole bloody thing read-only, inside and out. And it even figures out the literals for you, the clever bastard.",
      reasoning: 'Spike would promote the use of `as const` in a more enthusiastic and humorous way, highlighting its benefits.',
      confidence: 0.9
    },
    {
      existing_text: '`As const` does not have any runtime cost and recurses through the object, which makes it preferable over `Object.freeze` unless you need to ensure freezing at runtime specifically. Overall, `as const` provides a more convenient and efficient approach to creating immutable objects in TypeScript than using `Object.freeze`.',
      proposed_replacement: "`As const` doesn't slow you down one bit, and it does a proper job. So, unless you've got a good reason to use `Object.freeze`, stick with `as const`. It's the bee's knees, it is.",
      reasoning: 'Spike would conclude by emphasizing the advantages of `as const` in a more casual and persuasive way.',
      confidence: 0.95
    }
  ]
}
```