---
title: Output of PersonalityNerd against 100-readonly-type-helper.md
description: Generating proposed edits against a source text file using the PersonalityNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
In this exercise, we have a `handleSearchParams` function. This function consumes a search object that consists of several potential search parameters. These parameters include:

```ts
type SearchParams = {
  q?: string;
  page?: number;
  pageSize?: number;
  sort?: string;
  order?: "asc" | "desc";
};
```

All these parameters are optional, but they should be read-only. This is because they come directly from the URL and serve as the source of truth. Therefore, we shouldn't allow modifications to these parameters. 

As seen in the `handleSearchParams` function, if we try to modify these parameters, we should get errors telling us that we should not be able to modify these read-only parameters:

```ts
const handleSearchParams = (search: SearchParams) => {
  // Do something with the search params

  // @ts-expect-error Should not be able to modify readonly
  search.q = "test";

  // @ts-expect-error Should not be able to modify readonly
  search.page = 1;

  // @ts-expect-error Should not be able to modify readonly
  search.pageSize = 10;

  // @ts-expect-error Should not be able to modify readonly
  search.sort = "name";

  // @ts-expect-error Should not be able to modify readonly
  search.order = "asc";
};
```

However, because the search parameters are not read-only, we do not get any errors. This is because TypeScript infers the `search` parameter as a mutable object. Therefore, it allows us to modify the properties of the `search` object.

## Challenge

Your task is to make sure the potential search parameters are read-only.

An obvious way to enforce the read-only status is to append the `readonly` keyword on every parameter individually. However, a more efficient approach involves using a type helper. This helper can be applied to the `SearchParams` type, making all of its properties read-only at once.

Find and properly implement this type helper to mark every property in `SearchParams` as read-only.

# Resolution
TypeScript's `Readonly` type helper ensures that all object properties are read-only:

```typescript
Readonly<YourObjectHere>
```

If you try to modify a read-only property, you will encounter errors. However, this doesn't alter the characteristics of the properties themselves - they continue to remain optional.

With the `SearchParams` object, the properties will still be optional, but the `Readonly` type helper will ensure that they cannot be modified.

```typescript
type SearchParams = {
  q?: string;
  page?: number;
  pageSize?: number;
  sort?: string;
  order?: "asc" | "desc";
};

const handleSearchParams = (search: Readonly<SearchParams>) => {
  // Do something with the search params

  // @ts-expect-error Should not be able to modify readonly
  search.q = "test";

  // @ts-expect-error Should not be able to modify readonly
  search.page = 1;

  // @ts-expect-error Should not be able to modify readonly
  search.pageSize = 10;

  // @ts-expect-error Should not be able to modify readonly
  search.sort = "name";

  // @ts-expect-error Should not be able to modify readonly
  search.order = "asc";
};
```

One peculiarity of `Readonly` is that, much like many of TypeScript's type helpers, it only operates on the first level. It won't make properties read-only recursively.

It's also worth noting that the `Readonly` utility works like `Object.freeze`, behaving as though the object is frozen and can't be modified at the type level, but it doesn't influence the object at runtime.

### Operation Results:
This operation generated results by running the PersonalityNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
[Error running GPT: SyntaxError: Unexpected non-whitespace character after JSON at position 1524]
```

#### Anthropic:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'If you try to modify a read-only property, you will encounter errors.',
      proposed_replacement: "Try to modify a read-only property and you'll get smacked with errors faster than you can say 'bloody hell'.",
      reasoning: 'Adding some Spike-like snark and wit to the explanation of what happens when you try to modify read-only properties.',
      confidence: 0.8
    },
    {
      existing_text: "One peculiarity of `Readonly` is that, much like many of TypeScript's type helpers, it only operates on the first level. It won't make properties read-only recursively.",
      proposed_replacement: "Here's the thing about `Readonly` - it's as shallow as a kiddie pool. Much like the rest of TypeScript's so-called 'helpers', it only goes skin deep. Don't expect it to recursively lock things down like some sort of type-safety Terminator.",
      reasoning: "Injecting Spike's snarky humor and metaphors to colorfully explain the limitations of the `Readonly` type helper.",
      confidence: 0.9
    },
    {
      existing_text: "It's also worth noting that the `Readonly` utility works like `Object.freeze`, behaving as though the object is frozen and can't be modified at the type level, but it doesn't influence the object at runtime.",
      proposed_replacement: "Oh, and one more thing - `Readonly` is basically `Object.freeze`'s uptight cousin. It acts all high and mighty, pretending the object is frozen solid at the type level. But when push comes to shove at runtime, it's about as effective as a stake made of licorice.",
      reasoning: "Using Spike's voice to humorously point out the distinction between `Readonly`'s compile-time immutability and its lack of runtime enforcement, with a cheeky Buffy-universe metaphor thrown in.",
      confidence: 0.85
    }
  ]
}
```

#### Gemini:
```typescript
[Error running Gemini: SyntaxError: Expected property name or '}' in JSON at position 1]
```