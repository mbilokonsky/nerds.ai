---
title: Output of PersonalityNerd against 106-as-const-to-make-functions-infer-a-tuple.md
description: Generating proposed edits against a source text file using the PersonalityNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
In this exercise, we are dealing with an async function named `fetchData` that fetches data from a URL and returns a result.

If the fetch operation fails, this function returns a tuple. The first member of this tuple contains the error message and the second member is irrelevant in this case.

If the operation is successful, the function also returns a tuple. However, this time, the first member is `undefined` and the second member contains the fetched data.

Here's how the function is currently implemented:

```typescript
const fetchData = async () => {
  const result = await fetch("/");

  if (!result.ok) {
    return [new Error("Could not fetch data.")];
  }

  const data = await result.json();

  return [undefined, data];
};
```

Here's an async `example` function that uses `fetchData` and includes a couple of test cases:

```typescript
const example = async () => {
  const [error, data] = await fetchData();

  type Tests = [
    Expect<Equal<typeof error, Error | undefined>>, // red squiggly line under Equal<>
    Expect<Equal<typeof data, any>>,
  ];
};
```

Currently, both members of the tuple are inferred as `any`, which isn't ideal.


```typescript
const [error, data] = await fetchData();

// hovering over error and data shows:
const error: any
const data: any
```

## Challenge

Your challenge is to modify the `fetchData` function implementation so that TypeScript infers a Promise with a tuple for its return type.

Depending on whether or not the fetch operation is successful, the tuple should contain either an error message or a pair of `undefined` and the data fetched.

Hint: There are two possible approaches to solve this challenge. One way would be to define an explicit return type for the function. Alternatively, you could attempt to add or change type annotations for the `return` values within the function.

# Resolution
As mentioned, there are two different solutions to this challenge.

## Solution 1: Defining a Return Type

The first solution is to define a return type for the `fetchData` function.

Inside the `Promise` type, a tuple is defined with either `Error` or `undefined` as the first member, and an optional `any` as the second member:

```typescript
const fetchData = async (): Promise<[Error | undefined, any?]> => {
  ...
```

This technique works, but it's a little cumbersome.

## Solution 2: Using `as const`

Instead of specifying a return type, the second solution is to use `as const` on the return values:

```typescript
import { Equal, Expect } from "@total-typescript/helpers";

const fetchData = async () => {
  const result = await fetch("/");

  if (!result.ok) {
    return [new Error("Could not fetch data.")] as const; // added as const here
  }

  const data = await result.json();

  return [undefined, data] as const; // added as const here
};
```

With these changes in place, when we check the return type of `fetchData` in the `example` function, we can see that `error` is inferred as `Error | undefined`, and `data` is `any`:

```tsx
const example = async () => {
  const [error, data] = await fetchData();
  ...

// hovering over error shows:
const error: Error | undefined

// hovering over data shows:
const data: any
```

Using `as const` sets a variable is read-only, which assists TypeScript in accurately assigning the type of tuples.

In the case of this challenge, without `as const`, TypeScript could misinterpret the return value as `Promise<any[]>`. However, by using `as const`, TypeScript correctly observes the return value as a tuple (`Promise<[string | undefined, any]>`).

In summary, both techniques offer unique benefits. The first technique provides a straightforward approach to type definition, while the second leverages TypeScript's inference capabilities.

### Operation Results:
This operation generated results by running the PersonalityNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
[Error running GPT: SyntaxError: Expected ',' or '}' after property value in JSON at position 1253]
```

#### Anthropic:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'If the fetch operation fails, this function returns a tuple. The first member of this tuple contains the error message and the second member is irrelevant in this case.',
      proposed_replacement: "If the fetch operation goes all pear-shaped, this bloody function spits out a tuple. The first bit's got the error message and the second bit's about as useful as a one-legged man in an arse kicking contest.",
      reasoning: 'Adds some Spike-like snark and wit to the technical description of the error case.',
      confidence: 0.8
    },
    {
      existing_text: 'If the operation is successful, the function also returns a tuple. However, this time, the first member is `undefined` and the second member contains the fetched data.',
      proposed_replacement: "If by some miracle the operation actually works, the function also chucks out a tuple. 'Course, this time, the first bit's `undefined` and the second bit's got the data we went to all this trouble for.",
      reasoning: "Injects more of Spike's sarcastic personality while still conveying the key technical details.",
      confidence: 0.85
    },
    {
      existing_text: "Currently, both members of the tuple are inferred as `any`, which isn't ideal.",
      proposed_replacement: "Right now, TypeScript's about as helpful as a Fyarl demon in a china shop, saying both bits of the tuple are `any`. Not exactly the bee's knees, is it?",
      reasoning: "Expresses Spike's disdain for the current `any` type inference using a humorous simile.",
      confidence: 0.9
    },
    {
      existing_text: "This technique works, but it's a little cumbersome.",
      proposed_replacement: "This little trick does the job, but it's about as elegant as a drunken Chaos demon trying to waltz.",
      reasoning: 'Adds a colorful, Spike-esque metaphor to point out the awkwardness of the first solution.',
      confidence: 0.75
    },
    {
      existing_text: "In summary, both techniques offer unique benefits. The first technique provides a straightforward approach to type definition, while the second leverages TypeScript's inference capabilities.",
      proposed_replacement: "So there you have it. Two ways to solve this little conundrum that are about as different as Angel and me. The first one's the boring, straightforward route. The second's the clever one, getting TypeScript to do the heavy lifting. Take your pick.",
      reasoning: 'Concludes with a witty Spike-style summary comparing the two approaches to the contrasting personalities of Spike and Angel.',
      confidence: 0.95
    }
  ]
}
```

#### Gemini:
```typescript
{
  proposed_edits: [
    {
      existing_text: '## Challenge',
      proposed_replacement: "## Right then, listen up, you lot. Here's the challenge:",
      reasoning: 'Spike would definitely take this opportunity to be a bit more direct and commanding.',
      confidence: 0.8
    },
    {
      existing_text: 'Your challenge is to modify the `fetchData` function implementation so that TypeScript infers a Promise with a tuple for its return type.',
      proposed_replacement: "We need to tweak this `fetchData` thing so that TypeScript knows what's what. It should spit out a Promise with a tuple, you know, one of those fancy pairs of values. And that tuple? It's gotta tell us whether the fetch was a bloody success or a miserable failure.",
      reasoning: 'Spike would explain the challenge in a more casual and engaging way, using his own vocabulary and style.',
      confidence: 0.9
    },
    {
      existing_text: 'Depending on whether or not the fetch operation is successful, the tuple should contain either an error message or a pair of `undefined` and the data fetched.',
      proposed_replacement: "If the fetch goes pear-shaped, the tuple should have an error message. If it's all tickety-boo, we want `undefined` and the data it managed to snag.",
      reasoning: 'Spike would use more colorful language to describe the expected behavior of the function.',
      confidence: 0.9
    },
    {
      existing_text: 'Hint: There are two possible approaches to solve this challenge. One way would be to define an explicit return type for the function. Alternatively, you could attempt to add or change type annotations for the `return` values within the function.',
      proposed_replacement: "Oi, here's a hint: There's a couple of ways to skin this cat. You can either tell the function exactly what to return, or you can sprinkle some type annotations around like confetti.",
      reasoning: 'Spike would offer a hint in a more playful and sarcastic manner.',
      confidence: 0.85
    },
    {
      existing_text: '## Solution 1: Defining a Return Type',
      proposed_replacement: '## Solution 1: Laying Down the Law',
      reasoning: 'Spike would use a more assertive and metaphorical title for the first solution.',
      confidence: 0.75
    },
    {
      existing_text: "This technique works, but it's a little cumbersome.",
      proposed_replacement: "This does the trick, but it's a bit of a mouthful, innit?",
      reasoning: 'Spike would express his opinion on the first solution in a more casual and relatable way.',
      confidence: 0.8
    },
    {
      existing_text: '## Solution 2: Using `as const`',
      proposed_replacement: '## Solution 2: The Sneaky Trick',
      reasoning: 'Spike would use a more intriguing and playful title for the second solution.',
      confidence: 0.7
    },
    {
      existing_text: "In summary, both techniques offer unique benefits. The first technique provides a straightforward approach to type definition, while the second leverages TypeScript's inference capabilities.",
      proposed_replacement: "Right, so there you have it. Two ways to get the job done. One's straight to the point, the other's a bit more clever. Pick your poison.",
      reasoning: 'Spike would summarize the solutions in a more concise and opinionated way, offering a choice to the reader.',
      confidence: 0.9
    }
  ]
}
```