---
title: Output of PersonalityNerd against 101-intro-to-as-const.md
description: Generating proposed edits against a source text file using the PersonalityNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
Here we have the same setup as before: a `modifyButton` function that takes in an object of `buttonAttributes` which expects a type of `ButtonAttributes` containing either "button", "submit" or "reset":

```tsx
type ButtonAttributes = {
  type: "button" | "submit" | "reset";
};

const modifyButton = (attributes: ButtonAttributes) => {};

const buttonAttributes = {
  type: "button",
};

modifyButton(buttonAttributes); // red squiggly line under buttonAttributes
```

The problem arises when we try to pass `buttonAttributes` into the `modifyButton` function. We receive a TypeScript error stating that the argument of type `string` is not assignable to the parameter of type `ButtonAttributes`. This issue occurs because the `buttonAttributes.type` is mutable. 

Previously, we solved this by specifying a type for `buttonAttributes`. 

However, there's a more interesting approach where we can instruct TypeScript to treat `buttonAttributes` as if none of its properties can be changed. Essentially, we want to make `buttonAttributes` deeply read-only.

## Challenge

Your task is to find the appropriate annotation to apply to `buttonAttributes` to make it deeply read-only. However, you can only work on the `buttonAttributes` definition, and you're not allowed to use the `ButtonAttributes` type.

# Resolution
By adding `as const` to `buttonAttributes`, a `readonly` modifier is applied to the type. 

This fixes the inference issue on `type` so it will be inferred as a `button` and not a `string`:

```tsx
type ButtonAttributes = {
  type: "button" | "submit" | "reset";
};

const buttonAttributes = {
  type: "button",
} as const;

// hovering over buttonAttributes shows:
const buttonAttributes: {
  readonly type: "button";
}
```

There's no cost to using `as const` in your code, as it disappears at runtime.

Using `as const` is an incredibly effective pattern found in a multitude of applications, especially when configuring objects in TypeScript.

### Operation Results:
This operation generated results by running the PersonalityNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  thoughts: [
    "The document is technical and precise, focusing on TypeScript programming. Since no specific personality was provided, I'll adopt a Deadpool-inspired style to add a touch of humor and break the fourth wall, reminding the user to specify a personality next time."
  ],
  proposed_edits: [
    {
      existing_text: 'Here we have the same setup as before:',
      proposed_replacement: 'Alright, buckle up! Here we have the same setup as before:',
      reasoning: "Adding a casual, engaging opener with 'Alright, buckle up!' introduces a Deadpool-like playful tone to the technical content.",
      confidence: 0.9
    },
    {
      existing_text: 'This fixes the inference issue on `type` so it will be inferred as a `button` and not a `string`:',
      proposed_replacement: 'This nifty little trick fixes the inference issue on `type` so it will be inferred as a `button` and not just any old `string`:',
      reasoning: "Enhancing the sentence with 'nifty little trick' and 'just any old' adds a casual, Deadpool-esque flair, making the technical explanation more lively.",
      confidence: 0.9
    },
    {
      existing_text: "There's no cost to using `as const` in your code, as it disappears at runtime.",
      proposed_replacement: "The best part? Using `as const` won't cost you a dime or a minute of runtime, because it vanishes faster than my sense of responsibility.",
      reasoning: "Injecting humor with a self-referential joke about disappearing 'faster than my sense of responsibility' aligns with Deadpool's humorous and self-aware style.",
      confidence: 0.9
    },
    {
      existing_text: 'Using `as const` is an incredibly effective pattern found in a multitude of applications, especially when configuring objects in TypeScript.',
      proposed_replacement: 'Using `as const` is like the Swiss Army knife of TypeScript, incredibly effective and found in a multitude of applications, especially when configuring objects.',
      reasoning: "Comparing `as const` to a 'Swiss Army knife' adds a vivid, Deadpool-style analogy to the technical description, enhancing reader engagement.",
      confidence: 0.9
    }
  ]
}
```

#### Anthropic:
```typescript
{
  thoughts: [
    "The document is a technical tutorial about using TypeScript to make an object's properties read-only.",
    'The tone is informative and straightforward, focusing on explaining the problem and solution clearly.',
    "To inject some Deadpool-style personality, I'll look for opportunities to add humorous asides and fourth-wall breaking comments.",
    "I'll aim to keep the technical content and overall structure intact, just flavoring it with some Deadpool flair.",
    'Key areas to target are the introductory problem statement, the challenge to the reader, and the resolution explanation.'
  ],
  proposed_edits: [
    {
      existing_text: 'Here we have the same setup as before:',
      proposed_replacement: 'Well, well, well, look what we have here. The same old setup as before:',
      reasoning: 'Adds a conversational tone to draw in the reader, as if Deadpool is directly addressing them.',
      confidence: 0.8
    },
    {
      existing_text: 'Your task is to find the appropriate annotation to apply to `buttonAttributes` to make it deeply read-only.',
      proposed_replacement: 'Alright, listen up you code-slinging nerds. Your mission, should you choose to accept it (and you definitely should, I mean, why else are you here?), is to hunt down the elusive annotation that will make our little buddy `buttonAttributes` deeply read-only.',
      reasoning: "Reframes the challenge in an over-the-top way to mimic Deadpool's flippant attitude and tendency to address the audience directly.",
      confidence: 0.9
    },
    {
      existing_text: 'By adding `as const` to `buttonAttributes`, a `readonly` modifier is applied to the type.',
      proposed_replacement: "Drumroll please... the answer is: slapping an `as const` on `buttonAttributes`! Boom, a wild `readonly` modifier appears on the type. TypeScript used Strict Typing. It's super effective!",
      reasoning: 'Explains the solution using gaming references and onomatopoeia for humorous effect, while still conveying the key technical information.',
      confidence: 0.85
    },
    {
      existing_text: "There's no cost to using `as const` in your code, as it disappears at runtime.",
      proposed_replacement: 'Oh, and the best part? Using `as const` is like hiring a bouncer for your code - it keeps things in check during development, but when the party starts at runtime, it slips away into the night. No performance hit, no extra bytes. Nada.',
      reasoning: "Clarifies that there is no runtime cost using an extended metaphor that personifies the feature, aligning with Deadpool's offbeat explanatory style.",
      confidence: 0.9
    }
  ]
}
```

#### Gemini:
```typescript
{
  thoughts: [
    "Okay, I'm PersonalityNerd, and I'm ready to add some personality to this document. Let's see... it's a technical document about TypeScript. Hmm, no personality specified. Guess I'll go with my default, Deadpool!",
    "Alright, let's add some spice to this TypeScript talk. Time for some fourth-wall breaking and chimichangas!"
  ],
  proposed_edits: [
    {
      existing_text: '## Challenge',
      proposed_replacement: '## Challenge, True Believers!',
      reasoning: "Adding a bit of Deadpool's flair with a dramatic challenge introduction.",
      confidence: 0.8
    },
    {
      existing_text: 'Your task is to find the appropriate annotation to apply to `buttonAttributes` to make it deeply read-only.',
      proposed_replacement: 'Your mission, should you choose to accept it (and you better!), is to find the appropriate annotation to apply to `buttonAttributes` to make it deeply read-only. Remember, with great power comes great responsibility... to not mutate your objects!',
      reasoning: 'Injecting some Deadpool humor and a reference to his love for breaking the fourth wall.',
      confidence: 0.9
    },
    {
      existing_text: 'Using `as const` is an incredibly effective pattern found in a multitude of applications, especially when configuring objects in TypeScript.',
      proposed_replacement: 'Using `as const` is like having chimichangas for every meal - incredibly effective and satisfying, especially when configuring objects in TypeScript. Trust me, your code will thank you!',
      reasoning: 'Replacing a generic statement with a Deadpool-style simile involving his favorite food.',
      confidence: 0.7
    },
    {
      existing_text: "There's no cost to using `as const` in your code, as it disappears at runtime.",
      proposed_replacement: "There's no cost to using `as const` in your code, as it disappears at runtime, just like my enemies after I'm done with them. Poof!",
      reasoning: "Adding a dark humor quip in line with Deadpool's personality.",
      confidence: 0.6
    },
    {
      existing_text: 'By adding `as const` to `buttonAttributes`, a `readonly` modifier is applied to the type.',
      proposed_replacement: "Hey, you! Yeah, you reading this! Did you remember to tell me what personality you want for this document? If not, I'm just gonna keep going with the whole Deadpool thing. Just sayin'. Anyway, as I was saying, by adding `as const` to `buttonAttributes`, a `readonly` modifier is applied to the type.",
      reasoning: 'Breaking the fourth wall to remind the user to provide a personality while staying in character as Deadpool.',
      confidence: 1
    }
  ]
}
```