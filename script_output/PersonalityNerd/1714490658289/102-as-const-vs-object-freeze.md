---
title: Output of PersonalityNerd against 102-as-const-vs-object-freeze.md
description: Generating proposed edits against a source text file using the PersonalityNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
In our continued exploration of button types, we now have a modified version of `ButtonAttributes` that accepts `cancel` and `confirm` buttons. Each of these buttons exists as an object with a `type` of `ButtonType`. As in the previous exercises, the `ButtonType` remains either `button`, `submit`, or `reset`:

```tsx
type ButtonType = "button" | "submit" | "reset";

type ButtonAttributes = {
  cancel: {
    type: ButtonType;
  };
  confirm: {
    type: ButtonType;
  };
};
```

We call `Object.freeze()` on `buttonAttributes` which effectively locks the object, preventing any property alterations: 

```tsx
const modifyButtons = (attributes: ButtonAttributes) => {};

const buttonAttributes = Object.freeze({
  cancel: {
    type: "button",
  },
  confirm: {
    type: "button",
  },
});

modifyButtons(buttonAttributes); // red squiggly line under buttonAttributes
```

However, there's an error when we call `modifyButtons` with `buttonAttributes`.

## Challenge

Your task is to diagnose why we have an error when using `Object.freeze`, since it seems like it should work like `as const` did.

To solve the issue, you should only modify the `buttonAttributes` code.

# Resolution
In TypeScript, using `Object.freeze` is a common method for creating immutable objects. However, there are some significant differences between `Object.freeze` and `as const`.

When applying `Object.freeze` to the `buttonAttributes` object, we can see that a read-only modifier is being inferred on this object:

```typescript
type ButtonType = "button" | "submit" | "reset";

const buttonAttributes = Object.freeze({
  cancel: {
    type: "button" as ButtonType,
  },
  confirm: {
    type: "button" as ButtonType,
  },
});

// hovering over buttonAttributes shows:
const buttonAttributes: Readonly<{
  cancel: {
    type: "button";
  };
  confirm: {
    type: "button";
  };
}>
```

However, it's only working at the top level of the object. For example, if we add another type at the top level like `type: 'blah'`, the top level property is read-only. If we try to modify this, TypeScript will throw an error: 

```typescript
const buttonAttributes = Object.freeze({
  type: "blah",
  cancel: {
    type: "button" as ButtonType,
  },
  confirm: {
    type: "button" as ButtonType,
  },
});

buttonAttributes.type = "submit"; // red squiggly line under `type`

// Hovering over type shows:
Cannot assign to 'type' because it is a read-only property
```

However, `Object.freeze` doesn't work on nested levels of an object, so we can still modify the `type` property of `cancel` and `confirm`:

```typescript
buttonAttributes.confirm.type = "reset";
```

This behavior is because `Object.freeze` is not recursive; it only works on the top level of the object. Another thing to note about `Object.freeze` is that it runs at runtime, which can make your application slower.

An alternative to `Object.freeze` is using `as const`. When we modify `buttonAttributes` to use `as const` instead of `Object.freeze`, the whole object, including all nested layers, becomes read-only. Moreover, `as const` infers those literals too. 

```typescript
const buttonAttributes = {
  cancel: {
    type: "button" as ButtonType,
  },
  confirm: {
    type: "button" as ButtonType,
  },
} as const;

// Hovering over buttonAttributes shows:
const buttonAttributes: {
  readonly cancel: {
    readonly type: "button";
  };
  readonly confirm: {
    readonly type: "button";
  };
}
```

`As const` does not have any runtime cost and recurses through the object, which makes it preferable over `Object.freeze` unless you need to ensure freezing at runtime specifically. Overall, `as const` provides a more convenient and efficient approach to creating immutable objects in TypeScript than using `Object.freeze`.

### Operation Results:
This operation generated results by running the PersonalityNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  thoughts: [
    "The document is technical and precise, focusing on TypeScript's `Object.freeze` and `as const`. The personality wasn't specified, so I'll adopt a Deadpool-like style to add a touch of humor and break the fourth wall, reminding the user to specify a personality next time."
  ],
  proposed_edits: [
    {
      existing_text: 'In our continued exploration of button types, we now have a modified version of `ButtonAttributes` that accepts `cancel` and `confirm` buttons.',
      proposed_replacement: "In our epic saga of button types (yes, it's a saga now), we've upgraded our hero, `ButtonAttributes`, to bravely accept `cancel` and `confirm` buttons.",
      reasoning: "Adding a playful tone and framing the technical content as a 'saga' introduces a Deadpool-like whimsical and dramatic flair, making the document more engaging.",
      confidence: 0.9
    },
    {
      existing_text: 'Your task is to diagnose why we have an error when using `Object.freeze`, since it seems like it should work like `as const` did.',
      proposed_replacement: "Your mission, should you choose to accept it (and you should, because errors are annoying), is to figure out why `Object.freeze` is throwing a tantrum, even though it's supposed to play nice like `as const` did.",
      reasoning: 'Injecting a conversational and slightly humorous tone with a reference to mission-based narratives makes the technical challenge more relatable and less dry, fitting the Deadpool personality.',
      confidence: 0.9
    },
    {
      existing_text: 'This behavior is because `Object.freeze` is not recursive; it only works on the top level of the object.',
      proposed_replacement: 'This little quirk happens because `Object.freeze` is kinda lazyâ€”it only bothers with the top level of the object and ignores the rest.',
      reasoning: "Describing `Object.freeze` as 'lazy' adds a humorous and personified element to the explanation, making the technical detail more memorable and entertaining.",
      confidence: 0.9
    },
    {
      existing_text: 'Overall, `as const` provides a more convenient and efficient approach to creating immutable objects in TypeScript than using `Object.freeze`.',
      proposed_replacement: 'So, in the grand scheme of things, `as const` is like the superhero of immutability in TypeScript, swooping in to save the day more efficiently than `Object.freeze`.',
      reasoning: 'Using a superhero analogy enhances the playful and dramatic tone, aligning with a Deadpool-like personality while explaining the technical comparison.',
      confidence: 0.9
    },
    {
      existing_text: 'Your task is to diagnose why we have an error when using `Object.freeze`, since it seems like it should work like `as const` did.',
      proposed_replacement: "Hey, next time you drop by, how about you throw in a personality type for me to mimic? It's kinda my thing. Meanwhile, your task is to diagnose why we have an error when using `Object.freeze`, since it seems like it should work like `as const` did.",
      reasoning: 'Adding a direct address to the user with a reminder to specify a personality type for future tasks, maintaining the fourth-wall-breaking characteristic of Deadpool.',
      confidence: 0.95
    }
  ]
}
```

#### Anthropic:
```typescript
{
  thoughts: [
    'The document is a technical explanation of the differences between Object.freeze and as const in TypeScript.',
    "To inject some Deadpool-style personality, I'll look for opportunities to add humorous asides and fourth-wall breaking comments.",
    "I'll aim to keep the technical accuracy intact while lightening the tone a bit.",
    "A few strategic edits in Deadpool's voice should do the trick without altering the core meaning."
  ],
  proposed_edits: [
    {
      existing_text: 'there are some significant differences between `Object.freeze` and `as const`.',
      proposed_replacement: "there are some significant differences between `Object.freeze` and `as const`. And trust me, I would know - I've frozen my share of objects in my day! ðŸ˜‰",
      reasoning: "Adding a humorous aside in Deadpool's voice to acknowledge the technical detail in a playful way.",
      confidence: 0.8
    },
    {
      existing_text: "However, it's only working at the top level of the object.",
      proposed_replacement: "However, it's only working at the top level of the object. It's like `Object.freeze` has commitment issues, am I right?",
      reasoning: 'Injecting more Deadpool-esque humor to poke fun at the limitations of Object.freeze.',
      confidence: 0.7
    },
    {
      existing_text: 'Another thing to note about `Object.freeze` is that it runs at runtime, which can make your application slower.',
      proposed_replacement: "Another thing to note about `Object.freeze` is that it runs at runtime, which can make your application slower. But hey, sometimes you gotta take things slow, even if it's not as cool as freezing stuff with liquid nitrogen. *looks knowingly at the camera*",
      reasoning: 'Breaking the fourth wall with a humorous Deadpool-style aside that speaks directly to the reader.',
      confidence: 0.9
    },
    {
      existing_text: 'Overall, `as const` provides a more convenient and efficient approach to creating immutable objects in TypeScript than using `Object.freeze`.',
      proposed_replacement: 'Overall, `as const` provides a more convenient and efficient approach to creating immutable objects in TypeScript than using `Object.freeze`. So unless you really need that runtime freezing action, `as const` is the way to go. Trust me on this one, dear reader - would your old pal Deadpool ever steer you wrong?',
      reasoning: 'Closing out the explanation with some direct Deadpool narration to the reader, while still preserving the key technical recommendation.',
      confidence: 0.85
    }
  ]
}
```

#### Gemini:
```typescript
{
  thoughts: [
    "The provided text is a technical document explaining the differences between `Object.freeze` and `as const` in TypeScript. There's no personality specified, so I'll go with my default, which is Deadpool. Let's add some chimichangas to this text!"
  ],
  proposed_edits: [
    {
      existing_text: 'In TypeScript, using `Object.freeze` is a common method for creating immutable objects.',
      proposed_replacement: "In TypeScript, using `Object.freeze` is like trying to freeze a chimichanga - it might work on the outside, but the inside is still gonna be all gooey and delicious.  It's a common method for creating immutable objects, but it's not always the best.",
      reasoning: 'This adds a Deadpool-style quip to make the text more engaging and humorous.',
      confidence: 0.8
    },
    {
      existing_text: 'Another thing to note about `Object.freeze` is that it runs at runtime, which can make your application slower.',
      proposed_replacement: "Another thing to note about `Object.freeze` is that it runs at runtime, which can make your application slower than a snail trying to escape Cable's time-traveling shenanigans.",
      reasoning: 'This adds a Deadpool reference and a humorous comparison to emphasize the slowness caused by `Object.freeze`.',
      confidence: 0.9
    },
    {
      existing_text: 'Overall, `as const` provides a more convenient and efficient approach to creating immutable objects in TypeScript than using `Object.freeze`.',
      proposed_replacement: "Overall, `as const` is like the chimichanga of immutability - it's delicious, efficient, and gets the job done right. It's definitely a better choice than `Object.freeze`, unless you're into that partially-frozen, kinda-works thing.",
      reasoning: 'This concludes the document with another Deadpool-style comparison, reinforcing the superiority of `as const`.',
      confidence: 0.95
    },
    {
      existing_text: '## Challenge',
      proposed_replacement: '## Challenge - Hey, you! Yeah, you reading this! You forgot to tell me what personality to use, so I went with my own awesome self. Next time, give your friendly neighborhood PersonalityNerd some more info, okay?',
      reasoning: 'This is a Deadpool-style fourth-wall break to remind the user to provide personality information in future requests.',
      confidence: 1
    }
  ]
}
```