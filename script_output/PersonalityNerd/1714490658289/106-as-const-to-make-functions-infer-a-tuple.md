---
title: Output of PersonalityNerd against 106-as-const-to-make-functions-infer-a-tuple.md
description: Generating proposed edits against a source text file using the PersonalityNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
In this exercise, we are dealing with an async function named `fetchData` that fetches data from a URL and returns a result.

If the fetch operation fails, this function returns a tuple. The first member of this tuple contains the error message and the second member is irrelevant in this case.

If the operation is successful, the function also returns a tuple. However, this time, the first member is `undefined` and the second member contains the fetched data.

Here's how the function is currently implemented:

```typescript
const fetchData = async () => {
  const result = await fetch("/");

  if (!result.ok) {
    return [new Error("Could not fetch data.")];
  }

  const data = await result.json();

  return [undefined, data];
};
```

Here's an async `example` function that uses `fetchData` and includes a couple of test cases:

```typescript
const example = async () => {
  const [error, data] = await fetchData();

  type Tests = [
    Expect<Equal<typeof error, Error | undefined>>, // red squiggly line under Equal<>
    Expect<Equal<typeof data, any>>,
  ];
};
```

Currently, both members of the tuple are inferred as `any`, which isn't ideal.


```typescript
const [error, data] = await fetchData();

// hovering over error and data shows:
const error: any
const data: any
```

## Challenge

Your challenge is to modify the `fetchData` function implementation so that TypeScript infers a Promise with a tuple for its return type.

Depending on whether or not the fetch operation is successful, the tuple should contain either an error message or a pair of `undefined` and the data fetched.

Hint: There are two possible approaches to solve this challenge. One way would be to define an explicit return type for the function. Alternatively, you could attempt to add or change type annotations for the `return` values within the function.

# Resolution
As mentioned, there are two different solutions to this challenge.

## Solution 1: Defining a Return Type

The first solution is to define a return type for the `fetchData` function.

Inside the `Promise` type, a tuple is defined with either `Error` or `undefined` as the first member, and an optional `any` as the second member:

```typescript
const fetchData = async (): Promise<[Error | undefined, any?]> => {
  ...
```

This technique works, but it's a little cumbersome.

## Solution 2: Using `as const`

Instead of specifying a return type, the second solution is to use `as const` on the return values:

```typescript
import { Equal, Expect } from "@total-typescript/helpers";

const fetchData = async () => {
  const result = await fetch("/");

  if (!result.ok) {
    return [new Error("Could not fetch data.")] as const; // added as const here
  }

  const data = await result.json();

  return [undefined, data] as const; // added as const here
};
```

With these changes in place, when we check the return type of `fetchData` in the `example` function, we can see that `error` is inferred as `Error | undefined`, and `data` is `any`:

```tsx
const example = async () => {
  const [error, data] = await fetchData();
  ...

// hovering over error shows:
const error: Error | undefined

// hovering over data shows:
const data: any
```

Using `as const` sets a variable is read-only, which assists TypeScript in accurately assigning the type of tuples.

In the case of this challenge, without `as const`, TypeScript could misinterpret the return value as `Promise<any[]>`. However, by using `as const`, TypeScript correctly observes the return value as a tuple (`Promise<[string | undefined, any]>`).

In summary, both techniques offer unique benefits. The first technique provides a straightforward approach to type definition, while the second leverages TypeScript's inference capabilities.

### Operation Results:
This operation generated results by running the PersonalityNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  thoughts: [
    "The document is technical and precise, focusing on TypeScript programming. The personality to be applied wasn't specified, so I'll adopt a Deadpool-like style, which is humorous and breaks the fourth wall.",
    "I'll add a humorous comment to remind the user to specify a personality next time, while keeping the technical integrity of the document intact."
  ],
  proposed_edits: [
    {
      existing_text: 'In this exercise, we are dealing with an async function named `fetchData` that fetches data from a URL and returns a result.',
      proposed_replacement: "In this thrilling episode of 'Async Adventures', we're tackling a sneaky little async function named `fetchData` that fetches data from a URL and returns a result. Buckle up!",
      reasoning: 'Adding a playful introduction with a humorous tone to inject a Deadpool-like personality into the document.',
      confidence: 0.9
    },
    {
      existing_text: "Here's how the function is currently implemented:",
      proposed_replacement: "Here's the current superhero lineup of our function:",
      reasoning: 'Changing the introduction to the code snippet to something more playful and in line with a comic book style, fitting the Deadpool personality.',
      confidence: 0.9
    },
    {
      existing_text: 'Your challenge is to modify the `fetchData` function implementation so that TypeScript infers a Promise with a tuple for its return type.',
      proposed_replacement: 'Your mission, should you choose to accept it, is to tweak the `fetchData` function so that TypeScript infers a Promise with a tuple for its return type. This message will self-destruct in five seconds. Just kidding!',
      reasoning: 'Injecting a sense of humor and a reference to spy movies to make the challenge description more engaging and aligned with a Deadpool-like personality.',
      confidence: 0.9
    },
    {
      existing_text: 'As mentioned, there are two different solutions to this challenge.',
      proposed_replacement: "As I've graciously pointed out (because I'm helpful like that), there are two different solutions to this brain-buster.",
      reasoning: "Adding a self-referential and slightly arrogant comment to align with Deadpool's characteristic speech.",
      confidence: 0.9
    },
    {
      existing_text: "This technique works, but it's a little cumbersome.",
      proposed_replacement: "This technique works, but it's about as smooth as riding a unicycle on a cobblestone street.",
      reasoning: 'Using a humorous simile to describe the cumbersome nature of the technique, fitting the playful and vivid style of Deadpool.',
      confidence: 0.9
    }
  ]
}
```

#### Anthropic:
```typescript
{
  thoughts: [
    "Alright, let's see how we can Deadpool-ify this technical document.",
    'We need to inject some humor and irreverence while still keeping the core content intact.',
    "I'll try to add some fourth-wall breaking comments and Deadpool-style quips.",
    'The goal is to make it feel like Deadpool is explaining this TypeScript concept.'
  ],
  proposed_edits: [
    {
      existing_text: 'In this exercise, we are dealing with an async function named `fetchData` that fetches data from a URL and returns a result.',
      proposed_replacement: "In this exercise, we're gonna wrangle an async function called `fetchData`. It fetches data from a URL and returns a result. Simple enough for even you to understand, dear reader.",
      reasoning: "Adding some direct address to the reader in Deadpool's irreverent style.",
      confidence: 0.8
    },
    {
      existing_text: 'If the fetch operation fails, this function returns a tuple. The first member of this tuple contains the error message and the second member is irrelevant in this case.',
      proposed_replacement: 'If the fetch fails (hey, it happens to the best of us), this function returns a tuple. First part has the error message, second part is irrelevant. Kinda like the subplots in my movies, amirite?',
      reasoning: 'Injecting some humorous self-deprecating commentary.',
      confidence: 0.7
    },
    {
      existing_text: 'Your challenge is to modify the `fetchData` function implementation so that TypeScript infers a Promise with a tuple for its return type.',
      proposed_replacement: "Alright, here's your mission, should you choose to accept it (and you should, 'cause otherwise this document is useless): Modify `fetchData` so TypeScript figures out it returns a Promise with a tuple inside. Easy peasy lemon squeezy.",
      reasoning: 'Rephrasing the challenge in a more casual, action movie-like way.',
      confidence: 0.8
    },
    {
      existing_text: 'Hint: There are two possible approaches to solve this challenge. One way would be to define an explicit return type for the function. Alternatively, you could attempt to add or change type annotations for the `return` values within the function.',
      proposed_replacement: 'Hint: There are two ways to solve this. You could define the return type explicitly like a good little coder. Or, you could try adding some type annotations on the `return` values. Choose your poison, but remember: with great power comes great type-sponsibility!',
      reasoning: 'Adding a silly pun and presenting the hint in a more casual way.',
      confidence: 0.9
    }
  ]
}
```

#### Gemini:
```typescript
{
  thoughts: [
    "The provided text appears to be technical documentation or a tutorial related to TypeScript.  I'll need to make sure my edits maintain this technical style while injecting some personality.",
    "Since the user didn't specify a personality, I'll go with my default, Deadpool. Let's add some chimichangas and fourth-wall breaks to spice things up!"
  ],
  proposed_edits: [
    {
      existing_text: 'Your challenge is to modify the `fetchData` function implementation so that TypeScript infers a Promise with a tuple for its return type.',
      proposed_replacement: "Your challenge, should you choose to accept it (cue Mission Impossible theme music), is to tweak the `fetchData` function so TypeScript knows it's dealing with a Promise that returns a tuple. Think of it like a delicious chimichanga, but instead of beef and cheese, it's filled with errors and data.",
      reasoning: "This edit injects Deadpool's signature humor and pop-culture references while maintaining the technical context of the challenge.",
      confidence: 0.9
    },
    {
      existing_text: 'Hint: There are two possible approaches to solve this challenge.',
      proposed_replacement: "Psst, hey you! Yeah, you reading this. Don't forget to tell me what personality you want me to use next time. Anyway, here's a hint: there are two ways to tackle this bad boy.",
      reasoning: 'This edit adds a fourth-wall break where Deadpool reminds the user to provide a personality for future edits, while still offering a helpful hint.',
      confidence: 0.8
    },
    {
      existing_text: 'In summary, both techniques offer unique benefits.',
      proposed_replacement: 'To sum it all up, both methods have their own superpowers. Choose wisely, young Padawan.',
      reasoning: "This edit replaces the formal summary with a more playful and engaging conclusion, aligning with Deadpool's personality.",
      confidence: 0.7
    }
  ]
}
```