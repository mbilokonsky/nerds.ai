---
title: Output of PersonalityNerd against 103-readonly-arrays.md
description: Generating proposed edits against a source text file using the PersonalityNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
In this exercise, you'll be dealing with a function called `printNames`. This function accepts an array of `names` and prints each name to the console.

However, we want to add a special restriction to this function: it shouldn't be possible to mutate the array it receives. In other words, operations such as adding or changing an element in the array shouldn't be allowed:

```typescript
function printNames(names: string[]) {
  for (const name of names) {
    console.log(name);
  }

  // @ts-expect-error // red squiggly line
  names.push("John");

  // @ts-expect-error // red squiggly line
  names[0] = "Billy";
}
```

However, in the current implementation the `@ts-expect-error` directives show us that it's possible to mutate the array.

## Challenge

Your task is to determine what type should be assigned to the `names` parameter to ensure that the array cannot be mutated. There are two ways to solve this problem.

# Resolution
There are a couple of strategies for handling read-only arrays in TypeScript. Both are functionally identical, and your choice of which to use will ultimately come down to personal preference.

## Solution 1: Add the `readonly` Keyword

The first approach solution is to add the `readonly` keyword before the `string[]` array. It applies to the entire `string[]` array, converting it into a read-only array:

```typescript
function printNames(names: readonly string[]) {
  ...
}
```

With this setup, you can't call `.push()` or modify elements in the array. However, methods like `map()` and `reduce()` remain accessible since these create a copy of the array, and do not mutate the original.

## Solution 2: Use the `ReadonlyArray` Type Helper

Alternatively, TypeScript offers a type helper called `ReadonlyArray` that functions in the same way:

```typescript
function printNames(names: ReadonlyArray<string>) {
  ...
}
```

Regardless of which of these two methods you use, TypeScript will still display `readonly string[]` when hovering over the `names` parameter:

```typescript
// hovering over `names` shows:
(parameter) names: readonly string[]
```

No matter which syntax you prefer, both approaches are functionally identical. If you feel the need to choose one, it might be better to choose the `readonly string[]` syntax for consistency. Whichever you choose, remember they're essentially the same under the hood.

### Operation Results:
This operation generated results by running the PersonalityNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  thoughts: [
    "The document is technical and straightforward, focusing on TypeScript functionality. Since no specific personality was provided, I'll adopt a Deadpool-inspired style to make the text more engaging while reminding the user to specify a personality next time.",
    "I'll add a humorous remark to make the technical content more lively and engaging, consistent with Deadpool's irreverent style."
  ],
  proposed_edits: [
    {
      existing_text: "In this exercise, you'll be dealing with a function called `printNames`. This function accepts an array of `names` and prints each name to the console.",
      proposed_replacement: "In this exercise, you'll be wrestling with a function called `printNames`. This little troublemaker accepts an array of `names` and prints each name to the console, like it's no big deal.",
      reasoning: "Adding a playful tone and describing the function as a 'little troublemaker' injects a bit of Deadpool's characteristic humor into the document.",
      confidence: 0.9
    },
    {
      existing_text: 'There are a couple of strategies for handling read-only arrays in TypeScript. Both are functionally identical, and your choice of which to use will ultimately come down to personal preference.',
      proposed_replacement: "There are a couple of strategies for handling read-only arrays in TypeScript. Both are functionally identical, so pick your poisonâ€”it's all about personal preference, folks!",
      reasoning: "Adding 'pick your poison' and addressing the reader directly ('folks') adds a casual, Deadpool-like flair to the explanation.",
      confidence: 0.9
    },
    {
      existing_text: 'No matter which syntax you prefer, both approaches are functionally identical.',
      proposed_replacement: "No matter which syntax you prefer, both approaches are functionally identical. It's like choosing between tacos or chimichangas; either way, you're in for a treat!",
      reasoning: "Adding a comparison to choosing between tacos or chimichangas introduces a fun, relatable analogy typical of Deadpool's style.",
      confidence: 0.9
    }
  ]
}
```

#### Anthropic:
```typescript
{
  thoughts: [
    'The document is a technical explanation of how to make an array read-only in TypeScript.',
    'The tone is straightforward and informative, with a bit of a conversational style.',
    'To inject some Deadpool-style personality, I could add some humorous asides and fourth-wall breaking comments.',
    "I'll aim to keep the technical content intact while just tweaking the style to be more in line with Deadpool's irreverent personality."
  ],
  proposed_edits: [
    {
      existing_text: "In this exercise, you'll be dealing with a function called `printNames`. This function accepts an array of `names` and prints each name to the console.",
      proposed_replacement: "In this thrilling exercise, you'll be tangling with a function called `printNames`. This bad boy accepts an array of `names` and slaps each name onto the console.",
      reasoning: 'Injecting some Deadpool-style attitude and word choice to make the intro more engaging.',
      confidence: 0.8
    },
    {
      existing_text: "However, we want to add a special restriction to this function: it shouldn't be possible to mutate the array it receives.",
      proposed_replacement: "But wait, there's a twist! We want to slap a special restriction on this function: no one should be able to mess with the array it gets. Hands off, folks!",
      reasoning: 'Rephrasing the restriction in a more casual, humorous way that Deadpool might say it.',
      confidence: 0.9
    },
    {
      existing_text: 'Your task is to determine what type should be assigned to the `names` parameter to ensure that the array cannot be mutated. There are two ways to solve this problem.',
      proposed_replacement: "Okay, it's your time to shine. Your mission, should you choose to accept it (and you definitely should, I mean, why are you even here otherwise?), is to figure out what type we should slap on the `names` parameter to make sure nobody can mess with that array. There are a couple ways to crack this nut.",
      reasoning: 'Reframing the challenge in a way that directly addresses the reader and injects some Deadpool humor.',
      confidence: 0.85
    },
    {
      existing_text: 'Regardless of which of these two methods you use, TypeScript will still display `readonly string[]` when hovering over the `names` parameter:',
      proposed_replacement: 'No matter which of these two tricks you pull out of your hat, TypeScript is still gonna show `readonly string[]` when you hover over the `names` parameter. It\'s like it\'s saying "Nuh-uh, no touchy!":',
      reasoning: 'Adding a humorous metaphor and some imagined dialog from TypeScript to make this section more entertaining.',
      confidence: 0.75
    },
    {
      existing_text: "No matter which syntax you prefer, both approaches are functionally identical. If you feel the need to choose one, it might be better to choose the `readonly string[]` syntax for consistency. Whichever you choose, remember they're essentially the same under the hood.",
      proposed_replacement: "At the end of the day, both of these approaches are doing the same thing under the hood. It's like choosing between pancakes and waffles - sure, they look different, but they're both delicious breakfast carbs. If you're really twisting my arm, I'd say go with `readonly string[]` just to keep things consistent. But hey, you do you! Just remember, deep down, they're basically twins.",
      reasoning: 'Wrapping up with an extended breakfast metaphor and some classic Deadpool wisecracks and asides to the reader.',
      confidence: 0.9
    }
  ]
}
```

#### Gemini:
```typescript
{
  thoughts: [
    'The provided text is a technical document explaining how to make an array read-only in TypeScript. I need to transform it to match the personality of Deadpool, which is humorous, sarcastic, and often breaks the fourth wall.'
  ],
  proposed_edits: [
    {
      existing_text: "In this exercise, you'll be dealing with a function called `printNames`.",
      proposed_replacement: "Hey there, chimichanga chompers! Get ready to rumble with a function called `printNames`. It's gonna be legendary!",
      reasoning: 'Replace the formal introduction with a more Deadpool-like greeting that is energetic and humorous.',
      confidence: 0.9
    },
    {
      existing_text: "However, we want to add a special restriction to this function: it shouldn't be possible to mutate the array it receives.",
      proposed_replacement: "But here's the twist, folks! We're putting this function on lockdown. No mutations allowed. It's like trying to give Wolverine a haircut - ain't gonna happen!",
      reasoning: "Explain the 'no mutation' restriction in a more engaging and humorous way, using a pop-culture reference.",
      confidence: 0.85
    },
    {
      existing_text: 'Your task is to determine what type should be assigned to the `names` parameter to ensure that the array cannot be mutated.',
      proposed_replacement: "Your mission, should you choose to accept it (and you better, because I'm not explaining this again), is to figure out how to make that `names` parameter as unchangeable as my stunning good looks.",
      reasoning: "Rephrase the task in a more challenging and humorous way, with a reference to Deadpool's ego.",
      confidence: 0.8
    },
    {
      existing_text: 'There are two ways to solve this problem.',
      proposed_replacement: 'Lucky for you, there are two ways to skin this cat. Or, in this case, two ways to lock down that array. No cats were harmed in the making of this tutorial.',
      reasoning: 'Introduce the solutions in a more casual and humorous way, with a disclaimer about animal safety.',
      confidence: 0.75
    },
    {
      existing_text: 'The first approach solution is to add the `readonly` keyword before the `string[]` array.',
      proposed_replacement: "Option number one: slap that `readonly` keyword on there like it's a 'kick me' sign on Colossus' back. Boom! Instant read-only array.",
      reasoning: 'Explain the first solution in a more playful and humorous way, using a reference to another X-Men character.',
      confidence: 0.8
    },
    {
      existing_text: 'Alternatively, TypeScript offers a type helper called `ReadonlyArray` that functions in the same way:',
      proposed_replacement: "Or, if you're feeling fancy, you can use the `ReadonlyArray` type helper. It's like the Rolls Royce of read-only arrays, but without the hefty price tag.  Well, unless you count the existential dread of choosing between two functionally identical options.",
      reasoning: 'Explain the second solution in a more humorous way, highlighting the similarity between the two options and adding a touch of existentialism.',
      confidence: 0.75
    },
    {
      existing_text: 'No matter which syntax you prefer, both approaches are functionally identical.',
      proposed_replacement: "No matter which path you choose, you'll end up with the same result. It's like choosing between chimichangas and tacos - you can't go wrong!",
      reasoning: 'Reiterate the similarity between the two options in a more relatable and humorous way, using a food reference.',
      confidence: 0.8
    },
    {
      existing_text: 'If you feel the need to choose one, it might be better to choose the `readonly string[]` syntax for consistency.',
      proposed_replacement: "If you're really struggling to pick one, just go with `readonly string[]`. It's like the vanilla ice cream of TypeScript - simple, classic, and always a safe bet.  Unless you're lactose intolerant, then it's a one-way ticket to Painville.  Population: you.",
      reasoning: 'Provide a humorous recommendation for choosing one option over the other, with an unexpected twist.',
      confidence: 0.7
    },
    {
      existing_text: "Whichever you choose, remember they're essentially the same under the hood.",
      proposed_replacement: "And hey, before I forget, a little fourth-wall break for our dear user: Don't forget to tell me what personality you want me to channel next time! I can be anyone you want, from Shakespeare to a grumpy cat.  Just say the word, and I'll make it happen.  Unless it's something creepy, then I'm outta here.",
      reasoning: 'Add a Deadpool-style fourth-wall break to remind the user to provide personality instructions for future interactions, with a humorous limitation.',
      confidence: 0.95
    }
  ]
}
```