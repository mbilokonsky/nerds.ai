---
title: Output of CodeSnippetTunerNerd against 102-as-const-vs-object-freeze.md
description: Generating proposed edits against a source text file using the CodeSnippetTunerNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
In our continued exploration of button types, we now have a modified version of `ButtonAttributes` that accepts `cancel` and `confirm` buttons. Each of these buttons exists as an object with a `type` of `ButtonType`. As in the previous exercises, the `ButtonType` remains either `button`, `submit`, or `reset`:

```tsx
type ButtonType = "button" | "submit" | "reset";

type ButtonAttributes = {
  cancel: {
    type: ButtonType;
  };
  confirm: {
    type: ButtonType;
  };
};
```

We call `Object.freeze()` on `buttonAttributes` which effectively locks the object, preventing any property alterations: 

```tsx
const modifyButtons = (attributes: ButtonAttributes) => {};

const buttonAttributes = Object.freeze({
  cancel: {
    type: "button",
  },
  confirm: {
    type: "button",
  },
});

modifyButtons(buttonAttributes); // red squiggly line under buttonAttributes
```

However, there's an error when we call `modifyButtons` with `buttonAttributes`.

## Challenge

Your task is to diagnose why we have an error when using `Object.freeze`, since it seems like it should work like `as const` did.

To solve the issue, you should only modify the `buttonAttributes` code.

# Resolution
In TypeScript, using `Object.freeze` is a common method for creating immutable objects. However, there are some significant differences between `Object.freeze` and `as const`.

When applying `Object.freeze` to the `buttonAttributes` object, we can see that a read-only modifier is being inferred on this object:

```typescript
type ButtonType = "button" | "submit" | "reset";

const buttonAttributes = Object.freeze({
  cancel: {
    type: "button" as ButtonType,
  },
  confirm: {
    type: "button" as ButtonType,
  },
});

// hovering over buttonAttributes shows:
const buttonAttributes: Readonly<{
  cancel: {
    type: "button";
  };
  confirm: {
    type: "button";
  };
}>
```

However, it's only working at the top level of the object. For example, if we add another type at the top level like `type: 'blah'`, the top level property is read-only. If we try to modify this, TypeScript will throw an error: 

```typescript
const buttonAttributes = Object.freeze({
  type: "blah",
  cancel: {
    type: "button" as ButtonType,
  },
  confirm: {
    type: "button" as ButtonType,
  },
});

buttonAttributes.type = "submit"; // red squiggly line under `type`

// Hovering over type shows:
Cannot assign to 'type' because it is a read-only property
```

However, `Object.freeze` doesn't work on nested levels of an object, so we can still modify the `type` property of `cancel` and `confirm`:

```typescript
buttonAttributes.confirm.type = "reset";
```

This behavior is because `Object.freeze` is not recursive; it only works on the top level of the object. Another thing to note about `Object.freeze` is that it runs at runtime, which can make your application slower.

An alternative to `Object.freeze` is using `as const`. When we modify `buttonAttributes` to use `as const` instead of `Object.freeze`, the whole object, including all nested layers, becomes read-only. Moreover, `as const` infers those literals too. 

```typescript
const buttonAttributes = {
  cancel: {
    type: "button" as ButtonType,
  },
  confirm: {
    type: "button" as ButtonType,
  },
} as const;

// Hovering over buttonAttributes shows:
const buttonAttributes: {
  readonly cancel: {
    readonly type: "button";
  };
  readonly confirm: {
    readonly type: "button";
  };
}
```

`As const` does not have any runtime cost and recurses through the object, which makes it preferable over `Object.freeze` unless you need to ensure freezing at runtime specifically. Overall, `as const` provides a more convenient and efficient approach to creating immutable objects in TypeScript than using `Object.freeze`.

### Operation Results:
This operation generated results by running the CodeSnippetTunerNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'const modifyButtons = (attributes: ButtonAttributes) => {};',
      proposed_replacement: 'const modifyButtons = (attributes: Readonly<ButtonAttributes>) => {};',
      reasoning: "The function signature of `modifyButtons` should explicitly expect a read-only `ButtonAttributes` object to match the immutability enforced by `Object.freeze` on `buttonAttributes`. This change clarifies the expected immutability of the input parameter and aligns with the TypeScript type system's handling of `Object.freeze`.",
      confidence: 0.95
    }
  ]
}
```

#### Anthropic:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'const buttonAttributes = Object.freeze({\n' +
        '  cancel: {\n' +
        '    type: "button",\n' +
        '  },\n' +
        '  confirm: {\n' +
        '    type: "button",\n' +
        '  },\n' +
        '});',
      proposed_replacement: 'const buttonAttributes = {\n' +
        '  cancel: {\n' +
        '    type: "button",\n' +
        '  },\n' +
        '  confirm: {\n' +
        '    type: "button",\n' +
        '  },\n' +
        '} as const;',
      reasoning: 'Replacing Object.freeze() with as const will make the entire buttonAttributes object, including nested properties, read-only at compile time. This will resolve the type error when passing buttonAttributes to modifyButtons().',
      confidence: 1
    },
    {
      existing_text: 'type: "button" as ButtonType,',
      proposed_replacement: 'type: "button",',
      reasoning: 'When using as const, there is no need to explicitly cast the string literal "button" to the ButtonType. The as const assertion will infer the literal type.',
      confidence: 0.9
    }
  ]
}
```

#### Gemini:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'const modifyButtons = (attributes: ButtonAttributes) => {};',
      proposed_replacement: 'const modifyButtons = (attributes: Readonly<ButtonAttributes>) => {};',
      reasoning: 'The `modifyButtons` function should accept a `Readonly<ButtonAttributes>` type instead of `ButtonAttributes` to ensure that the function does not attempt to modify the passed-in `buttonAttributes` object, which is intended to be immutable due to the use of `Object.freeze`.',
      confidence: 1
    }
  ]
}
```