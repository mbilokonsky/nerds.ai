---
title: Output of CodeSnippetTunerNerd against 097-let-and-const-inference.md
description: Generating proposed edits against a source text file using the CodeSnippetTunerNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
Here we have an interface `ButtonAttributes` which has one property `type` that can be of three possible values: `button`, `submit`, or `reset`.

We have a `let` declaration for a variable `type` that is assigned the value `"button"`.

Then we create an object `buttonAttributes` of type `ButtonAttributes` and assign the `type` value into it.

```typescript
type ButtonAttributes = {
  type: "button" | "submit" | "reset";
};

let type = "button";

const buttonAttributes: ButtonAttributes = {
  type, // red squiggly line under type
};
```

This behavior is parallel to button elements in the Document Object Model (DOM), where the type of the button element can have these three values.

Currently there is an error under `type` inside of the `buttonAttributes` object.

## Challenge

Your challenge is to determine why there's an error and how to fix it.

Note that you're only allowed to change the line `let type = "button"`, however you can modify the runtime behavior of the code or give it a type if necessary.

# Resolution
The first step in fixing the error inside of `buttonAttributes` is to read the error message.

```typescript
type ButtonAttributes = {
  type: "button" | "submit" | "reset";
};

let type = "button";

const buttonAttributes: ButtonAttributes = {
  type, // red squiggly line under type
};
```

Hovering over the red squiggly line, we see the following error message:

```typescript
Type 'string' is not assignable to type '"button" | "submit" | "reset"'
```

However, when we hover over `type`'s declaration, it is inferred as a `string`:

```typescript
// hovering over type
let type = "button";

// shows
let type: string
```

This is strange, because we explicitly assigned `type` to be "button". Why doesn't TypeScript infer it as the literal type "button"?

The answer lies in mutability.

Variables declared with `let` can be modified later in the code. With this in mind, TypeScript infers `let` as the most general possible version of the type to allow potential mutations.

Even though we could explicitly declare `type` to be either "button", "submit", or "reset", by default, TypeScript infers it as a `string` because `let` allows mutations. 

## The Solution

When we replace `let` with `const`, however, TypeScript infers `type` as the literal type "button":

```typescript
const type = "button"
```

This works because `const` ensures immutability. It does not allow any changes to the `type` value later in the code:

```typescript
// changing type after declaring it as const
type = "something strange"; // red squiggly line under type

// Hovering over type shows:
// Error: Cannot assign to 'type' because it is a constant
```

With `const`, we can successfully assign `type` to our button attributes without errors:

```typescript
type ButtonAttributes = {
  type: "button" | "submit" | "reset";
};

const buttonAttributes: ButtonAttributes = {
  type,
};
```

TypeScript is mirroring JavaScript behavior to prevent possible runtime errors. When you declare a variable as `const`, TypeScript infers it as the literal type you specified.

It's important to remember that TypeScript pays close attention to mutability when inferring types. It aims to mimic JavaScript behavior, focusing on ensuring correct types and reducing potential mutability-related issues in your code.

### Operation Results:
This operation generated results by running the CodeSnippetTunerNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'let type = "button";',
      proposed_replacement: 'const type = "button";',
      reasoning: "Changing 'let' to 'const' ensures that the variable 'type' is treated as a constant, which allows TypeScript to infer its type as the literal 'button' instead of a general 'string'. This change resolves the type assignment error in the 'buttonAttributes' object.",
      confidence: 1
    }
  ]
}
```

#### Anthropic:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'let type = "button";',
      proposed_replacement: 'const type = "button" as const;',
      reasoning: `Changing 'let' to 'const' will make the 'type' variable immutable, allowing TypeScript to infer it as the literal type "button" instead of the broader 'string' type. Adding 'as const' explicitly tells TypeScript to infer the narrowest, read-only type for 'type'.`,
      confidence: 1
    },
    {
      existing_text: '// changing type after declaring it as const\n' +
        'type = "something strange"; // red squiggly line under type',
      proposed_replacement: '// changing type after declaring it as const\n' +
        `// type = "something strange"; // Error: Cannot assign to 'type' because it is a constant`,
      reasoning: "The code snippet showing an attempt to reassign 'type' after it is declared as const should be commented out, as it will not compile. The error comment can be updated to use the exact error wording from TypeScript.",
      confidence: 0.9
    }
  ]
}
```

#### Gemini:
```typescript
{
  proposed_edits: [
    {
      existing_text: '```typescript\n' +
        'type ButtonAttributes = {\n' +
        '  type: "button" | "submit" | "reset";\n' +
        '};\n' +
        '\n' +
        'let type = "button";\n' +
        '\n' +
        'const buttonAttributes: ButtonAttributes = {\n' +
        '  type, // red squiggly line under type\n' +
        '};\n' +
        '```',
      proposed_replacement: '```typescript\n' +
        'type ButtonAttributes = {\n' +
        '  type: "button" | "submit" | "reset";\n' +
        '};\n' +
        '\n' +
        'const type = "button"; // change to const\n' +
        '\n' +
        'const buttonAttributes: ButtonAttributes = {\n' +
        '  type,\n' +
        '};\n' +
        '```',
      reasoning: "The code snippet demonstrates a TypeScript error where a variable declared with `let` is inferred as a string type, even though it's assigned a specific string literal. The text explains that this is due to mutability, as `let` allows for reassignment. To fix the error and align with the explanation, the code snippet should be changed to use `const` instead of `let`, ensuring immutability and the correct type inference.",
      confidence: 1
    }
  ]
}
```