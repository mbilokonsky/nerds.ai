---
title: Output of CodeSnippetTunerNerd against 104-readonly-arrays-assignability-to-mutable-arrays.md
description: Generating proposed edits against a source text file using the CodeSnippetTunerNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

When working with TypeScript, it's important to understand the distinction between read-only and mutable arrays.

In this example, `printNamesReadOnly` and `printNamesMutable`, which are functionally identical, except `printNamesReadOnly` takes a read-only array of names as a parameter whereas `printNamesMutable` takes a mutable array:

```typescript
function printNamesReadOnly(names: readonly string[]) {
  for (const name of names) {
    console.log(name);
  }
}

function printNamesMutable(names: string[]) {
  for (const name of names) {
    console.log(name);
  }
}
```

When we create a mutable array of names, it can be passed as an argument to both of these functions:

```typescript
const mutableNames = ["John", "Jane", "Mike"];

printNamesReadOnly(mutableNames);
printNamesMutable(mutableNames);
```

This works because specifying `readonly` on the `printNamesReadOnly` function parameter only guarantees that it won't alter the array's content. Thus, it doesn't matter if we pass a mutable array because it won't be changed.

However, the reverse isn't true.

If we declare a read-only array, which we often do using the `as const` syntax, we can only pass it to `printNamesReadOnly`. Attempting to pass it to `printNamesMutable` will yield an error:

```typescript
const readonlyNames = ["John", "Jane", "Mike"] as const;

printNamesReadOnly(readonlyNames);

printNamesMutable(readonlyNames); // red squiggly line under readonlyNames

// hovering over readonlyNames shows:
Error: Argument of type 'readonly ["John", "Jane", "Mike"]' is not assignable to parameter of type 'string[]'
```

The error arises due to the potential for a mutable array to be altered inside of the function, which isn't acceptable for a read-only array.

In essence, read-only arrays can only be assigned to other read-only types. This characteristic is somewhat viral: if a function deep down the call stack expects a `readonly` array, then that array must remain `readonly` throughout. Doing so ensures that the array won't be mutated in any manner as it moves down the stack.

In conclusion, even though you can assign mutable arrays to read-only arrays, you cannot assign read-only arrays to mutable arrays.

### Operation Results:
This operation generated results by running the CodeSnippetTunerNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'const readonlyNames = ["John", "Jane", "Mike"] as const;',
      proposed_replacement: 'const readonlyNames: readonly string[] = ["John", "Jane", "Mike"];',
      reasoning: "Using 'as const' makes the array's elements also treated as constants (i.e., their types are literal types like 'John', 'Jane', etc.), which is stricter than necessary for demonstrating the read-only array concept. Declaring the type as 'readonly string[]' is more appropriate and aligns better with the example's intent to show type compatibility between read-only and mutable arrays.",
      confidence: 0.9
    }
  ]
}
```

#### Anthropic:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'printNamesReadOnly(names: readonly string[])',
      proposed_replacement: 'function printNamesReadOnly(names: readonly string[]): void',
      reasoning: "Adding the return type ': void' makes it clear that the function doesn't return a value.",
      confidence: 0.8
    },
    {
      existing_text: 'printNamesMutable(names: string[])',
      proposed_replacement: 'function printNamesMutable(names: string[]): void',
      reasoning: "Adding the return type ': void' makes it clear that the function doesn't return a value.",
      confidence: 0.8
    },
    {
      existing_text: 'const readonlyNames = ["John", "Jane", "Mike"] as const;',
      proposed_replacement: 'const readonlyNames = ["John", "Jane", "Mike"] as const;',
      reasoning: "The code snippet is correct. The 'as const' syntax is used correctly to create a read-only array.",
      confidence: 1
    },
    {
      existing_text: 'printNamesMutable(readonlyNames); // red squiggly line under readonlyNames',
      proposed_replacement: 'printNamesMutable(readonlyNames as string[]); // This will remove the error',
      reasoning: "If you really need to pass a read-only array to a function expecting a mutable array, you can use a type assertion 'as string[]' to remove the error. However, this should be done with caution as it subverts the read-only protection.",
      confidence: 0.9
    }
  ]
}
```

#### Gemini:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'function printNamesMutable(names: string[]) {',
      proposed_replacement: 'function printNamesMutable(names: string[]) {\n' +
        '  // Note: This function is intentionally identical to printNamesReadOnly for demonstration purposes.',
      reasoning: 'Adding a comment to clarify why printNamesMutable is identical to printNamesReadOnly.',
      confidence: 0.9
    }
  ]
}
```