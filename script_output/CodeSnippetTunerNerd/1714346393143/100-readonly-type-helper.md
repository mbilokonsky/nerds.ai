---
title: Output of CodeSnippetTunerNerd against 100-readonly-type-helper.md
description: Generating proposed edits against a source text file using the CodeSnippetTunerNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
In this exercise, we have a `handleSearchParams` function. This function consumes a search object that consists of several potential search parameters. These parameters include:

```ts
type SearchParams = {
  q?: string;
  page?: number;
  pageSize?: number;
  sort?: string;
  order?: "asc" | "desc";
};
```

All these parameters are optional, but they should be read-only. This is because they come directly from the URL and serve as the source of truth. Therefore, we shouldn't allow modifications to these parameters. 

As seen in the `handleSearchParams` function, if we try to modify these parameters, we should get errors telling us that we should not be able to modify these read-only parameters:

```ts
const handleSearchParams = (search: SearchParams) => {
  // Do something with the search params

  // @ts-expect-error Should not be able to modify readonly
  search.q = "test";

  // @ts-expect-error Should not be able to modify readonly
  search.page = 1;

  // @ts-expect-error Should not be able to modify readonly
  search.pageSize = 10;

  // @ts-expect-error Should not be able to modify readonly
  search.sort = "name";

  // @ts-expect-error Should not be able to modify readonly
  search.order = "asc";
};
```

However, because the search parameters are not read-only, we do not get any errors. This is because TypeScript infers the `search` parameter as a mutable object. Therefore, it allows us to modify the properties of the `search` object.

## Challenge

Your task is to make sure the potential search parameters are read-only.

An obvious way to enforce the read-only status is to append the `readonly` keyword on every parameter individually. However, a more efficient approach involves using a type helper. This helper can be applied to the `SearchParams` type, making all of its properties read-only at once.

Find and properly implement this type helper to mark every property in `SearchParams` as read-only.

# Resolution
TypeScript's `Readonly` type helper ensures that all object properties are read-only:

```typescript
Readonly<YourObjectHere>
```

If you try to modify a read-only property, you will encounter errors. However, this doesn't alter the characteristics of the properties themselves - they continue to remain optional.

With the `SearchParams` object, the properties will still be optional, but the `Readonly` type helper will ensure that they cannot be modified.

```typescript
type SearchParams = {
  q?: string;
  page?: number;
  pageSize?: number;
  sort?: string;
  order?: "asc" | "desc";
};

const handleSearchParams = (search: Readonly<SearchParams>) => {
  // Do something with the search params

  // @ts-expect-error Should not be able to modify readonly
  search.q = "test";

  // @ts-expect-error Should not be able to modify readonly
  search.page = 1;

  // @ts-expect-error Should not be able to modify readonly
  search.pageSize = 10;

  // @ts-expect-error Should not be able to modify readonly
  search.sort = "name";

  // @ts-expect-error Should not be able to modify readonly
  search.order = "asc";
};
```

One peculiarity of `Readonly` is that, much like many of TypeScript's type helpers, it only operates on the first level. It won't make properties read-only recursively.

It's also worth noting that the `Readonly` utility works like `Object.freeze`, behaving as though the object is frozen and can't be modified at the type level, but it doesn't influence the object at runtime.

### Operation Results:
This operation generated results by running the CodeSnippetTunerNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'type SearchParams = {\n' +
        '  q?: string;\n' +
        '  page?: number;\n' +
        '  pageSize?: number;\n' +
        '  sort?: string;\n' +
        '  order?: "asc" | "desc";\n' +
        '};',
      proposed_replacement: 'type SearchParams = Readonly<{\n' +
        '  q?: string;\n' +
        '  page?: number;\n' +
        '  pageSize?: number;\n' +
        '  sort?: string;\n' +
        '  order?: "asc" | "desc";\n' +
        '}>;',
      reasoning: "The original type definition of 'SearchParams' does not enforce the properties to be read-only. By wrapping the type definition with 'Readonly<...>', all properties of 'SearchParams' will be read-only, which aligns with the requirement specified in the problem statement.",
      confidence: 1
    }
  ]
}
```

#### Anthropic:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'const handleSearchParams = (search: SearchParams) => {',
      proposed_replacement: 'const handleSearchParams = (search: Readonly<SearchParams>) => {',
      reasoning: 'By wrapping the SearchParams type with Readonly<>, it will make all properties of the search object read-only, preventing them from being modified within the handleSearchParams function.',
      confidence: 1
    },
    {
      existing_text: '// @ts-expect-error Should not be able to modify readonly',
      proposed_replacement: '',
      reasoning: 'The @ts-expect-error comments are no longer needed once the search parameter is properly typed as Readonly<SearchParams>. The TypeScript compiler will correctly flag the attempts to modify the read-only properties as errors.',
      confidence: 1
    }
  ]
}
```

#### Gemini:
```typescript
{ proposed_edits: [] }
```