---
title: Output of CodeSnippetTunerNerd against 101-intro-to-as-const.md
description: Generating proposed edits against a source text file using the CodeSnippetTunerNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
Here we have the same setup as before: a `modifyButton` function that takes in an object of `buttonAttributes` which expects a type of `ButtonAttributes` containing either "button", "submit" or "reset":

```tsx
type ButtonAttributes = {
  type: "button" | "submit" | "reset";
};

const modifyButton = (attributes: ButtonAttributes) => {};

const buttonAttributes = {
  type: "button",
};

modifyButton(buttonAttributes); // red squiggly line under buttonAttributes
```

The problem arises when we try to pass `buttonAttributes` into the `modifyButton` function. We receive a TypeScript error stating that the argument of type `string` is not assignable to the parameter of type `ButtonAttributes`. This issue occurs because the `buttonAttributes.type` is mutable. 

Previously, we solved this by specifying a type for `buttonAttributes`. 

However, there's a more interesting approach where we can instruct TypeScript to treat `buttonAttributes` as if none of its properties can be changed. Essentially, we want to make `buttonAttributes` deeply read-only.

## Challenge

Your task is to find the appropriate annotation to apply to `buttonAttributes` to make it deeply read-only. However, you can only work on the `buttonAttributes` definition, and you're not allowed to use the `ButtonAttributes` type.

# Resolution
By adding `as const` to `buttonAttributes`, a `readonly` modifier is applied to the type. 

This fixes the inference issue on `type` so it will be inferred as a `button` and not a `string`:

```tsx
type ButtonAttributes = {
  type: "button" | "submit" | "reset";
};

const buttonAttributes = {
  type: "button",
} as const;

// hovering over buttonAttributes shows:
const buttonAttributes: {
  readonly type: "button";
}
```

There's no cost to using `as const` in your code, as it disappears at runtime.

Using `as const` is an incredibly effective pattern found in a multitude of applications, especially when configuring objects in TypeScript.

### Operation Results:
This operation generated results by running the CodeSnippetTunerNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'modifyButton(buttonAttributes); // red squiggly line under buttonAttributes',
      proposed_replacement: 'modifyButton(buttonAttributes);',
      reasoning: "The comment about the red squiggly line under 'buttonAttributes' is misleading in the context of the provided solution. Since the solution involves using 'as const' to fix the type inference issue, the comment about the error should be removed to avoid confusion.",
      confidence: 0.95
    }
  ]
}
```

#### Anthropic:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'const modifyButton = (attributes: ButtonAttributes) => {};',
      proposed_replacement: 'const modifyButton = (attributes: ButtonAttributes): void => {};',
      reasoning: "It's a good practice to explicitly specify the return type of a function, even if it doesn't return anything. In this case, adding `: void` makes it clear that the function doesn't return a value.",
      confidence: 0.8
    },
    {
      existing_text: 'modifyButton(buttonAttributes); // red squiggly line under buttonAttributes',
      proposed_replacement: 'modifyButton(buttonAttributes);',
      reasoning: "The comment about the 'red squiggly line' is no longer relevant after applying the `as const` fix. It can be removed to avoid confusion.",
      confidence: 0.9
    },
    {
      existing_text: '// hovering over buttonAttributes shows:',
      proposed_replacement: '// Hovering over `buttonAttributes` shows:',
      reasoning: "Using inline code formatting for `buttonAttributes` helps it stand out and makes it clear it's referring to the code symbol. Capitalizing the comment also improves readability.",
      confidence: 0.7
    }
  ]
}
```

#### Gemini:
```typescript
{
  proposed_edits: [
    {
      existing_text: '```tsx\n' +
        'type ButtonAttributes = {\n' +
        '  type: "button" | "submit" | "reset";\n' +
        '};\n' +
        '\n' +
        'const modifyButton = (attributes: ButtonAttributes) => {};\n' +
        '\n' +
        'const buttonAttributes = {\n' +
        '  type: "button",\n' +
        '};\n' +
        '\n' +
        'modifyButton(buttonAttributes); // red squiggly line under buttonAttributes\n' +
        '```',
      proposed_replacement: '```tsx\n' +
        'type ButtonAttributes = {\n' +
        '  type: "button" | "submit" | "reset";\n' +
        '};\n' +
        '\n' +
        'const modifyButton = (attributes: ButtonAttributes) => {};\n' +
        '\n' +
        '// The following line demonstrates the problem described above\n' +
        'const buttonAttributes = {\n' +
        '  type: "button",\n' +
        '};\n' +
        '\n' +
        'modifyButton(buttonAttributes); // red squiggly line under buttonAttributes\n' +
        '```',
      reasoning: 'The code block is missing a comment explaining that it is demonstrating the problem described in the text.',
      confidence: 0.9
    },
    {
      existing_text: '```tsx\n' +
        'type ButtonAttributes = {\n' +
        '  type: "button" | "submit" | "reset";\n' +
        '};\n' +
        '\n' +
        'const buttonAttributes = {\n' +
        '  type: "button",\n' +
        '} as const;\n' +
        '\n' +
        '// hovering over buttonAttributes shows:\n' +
        'const buttonAttributes: {\n' +
        '  readonly type: "button";\n' +
        '}\n' +
        '```',
      proposed_replacement: '```tsx\n' +
        'type ButtonAttributes = {\n' +
        '  type: "button" | "submit" | "reset";\n' +
        '};\n' +
        '\n' +
        'const buttonAttributes = {\n' +
        '  type: "button",\n' +
        '} as const;\n' +
        '\n' +
        "// The following demonstrates the resolved type of buttonAttributes after applying 'as const'\n" +
        'const buttonAttributes: {\n' +
        '  readonly type: "button";\n' +
        '}\n' +
        '```',
      reasoning: "The code block is missing a comment explaining that it is demonstrating the resolved type of buttonAttributes after applying 'as const'",
      confidence: 0.9
    }
  ]
}
```