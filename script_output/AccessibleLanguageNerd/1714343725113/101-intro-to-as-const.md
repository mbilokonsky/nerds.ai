---
title: Output of AccessibleLanguageNerd against 101-intro-to-as-const.md
description: Generating proposed edits against a source text file using the AccessibleLanguageNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
Here we have the same setup as before: a `modifyButton` function that takes in an object of `buttonAttributes` which expects a type of `ButtonAttributes` containing either "button", "submit" or "reset":

```tsx
type ButtonAttributes = {
  type: "button" | "submit" | "reset";
};

const modifyButton = (attributes: ButtonAttributes) => {};

const buttonAttributes = {
  type: "button",
};

modifyButton(buttonAttributes); // red squiggly line under buttonAttributes
```

The problem arises when we try to pass `buttonAttributes` into the `modifyButton` function. We receive a TypeScript error stating that the argument of type `string` is not assignable to the parameter of type `ButtonAttributes`. This issue occurs because the `buttonAttributes.type` is mutable. 

Previously, we solved this by specifying a type for `buttonAttributes`. 

However, there's a more interesting approach where we can instruct TypeScript to treat `buttonAttributes` as if none of its properties can be changed. Essentially, we want to make `buttonAttributes` deeply read-only.

## Challenge

Your task is to find the appropriate annotation to apply to `buttonAttributes` to make it deeply read-only. However, you can only work on the `buttonAttributes` definition, and you're not allowed to use the `ButtonAttributes` type.

# Resolution
By adding `as const` to `buttonAttributes`, a `readonly` modifier is applied to the type. 

This fixes the inference issue on `type` so it will be inferred as a `button` and not a `string`:

```tsx
type ButtonAttributes = {
  type: "button" | "submit" | "reset";
};

const buttonAttributes = {
  type: "button",
} as const;

// hovering over buttonAttributes shows:
const buttonAttributes: {
  readonly type: "button";
}
```

There's no cost to using `as const` in your code, as it disappears at runtime.

Using `as const` is an incredibly effective pattern found in a multitude of applications, especially when configuring objects in TypeScript.

### Operation Results:
This operation generated results by running the AccessibleLanguageNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'Here we have the same setup as before: a `modifyButton` function that takes in an object of `buttonAttributes` which expects a type of `ButtonAttributes` containing either "button", "submit" or "reset":',
      proposed_replacement: 'Here we have a similar setup as before: a `modifyButton` function that accepts an object named `buttonAttributes`. This object should conform to the `ButtonAttributes` type, which allows the values "button", "submit", or "reset":',
      reasoning: "The revised text clarifies the function's requirement and the role of `buttonAttributes`, making it easier to understand for readers unfamiliar with the context.",
      confidence: 0.9
    },
    {
      existing_text: 'The problem arises when we try to pass `buttonAttributes` into the `modifyButton` function. We receive a TypeScript error stating that the argument of type `string` is not assignable to the parameter of type `ButtonAttributes`. This issue occurs because the `buttonAttributes.type` is mutable.',
      proposed_replacement: 'The issue occurs when we attempt to pass `buttonAttributes` into the `modifyButton` function. A TypeScript error appears, indicating that the argument of type `string` cannot be assigned to a parameter of type `ButtonAttributes`. This error happens because the `buttonAttributes.type` property can be changed, making it mutable.',
      reasoning: 'The revised text simplifies the explanation of the error and the reason behind it, making it more accessible to readers who may not be familiar with programming terminology.',
      confidence: 0.9
    },
    {
      existing_text: "However, there's a more interesting approach where we can instruct TypeScript to treat `buttonAttributes` as if none of its properties can be changed. Essentially, we want to make `buttonAttributes` deeply read-only.",
      proposed_replacement: "However, there's a more effective approach where we can configure TypeScript to treat `buttonAttributes` as if its properties are unchangeable. Essentially, we aim to make `buttonAttributes` deeply read-only.",
      reasoning: 'The revision simplifies the language and clarifies the goal of making `buttonAttributes` unchangeable, enhancing readability.',
      confidence: 0.9
    },
    {
      existing_text: 'By adding `as const` to `buttonAttributes`, a `readonly` modifier is applied to the type.',
      proposed_replacement: 'By appending `as const` to `buttonAttributes`, we apply a `readonly` modifier to its type.',
      reasoning: 'The revision clarifies the action and its effect on `buttonAttributes`, making the explanation more direct and easier to follow.',
      confidence: 0.9
    },
    {
      existing_text: 'This fixes the inference issue on `type` so it will be inferred as a `button` and not a `string`:',
      proposed_replacement: 'This adjustment resolves the inference issue with `type`, ensuring it is recognized as `button` rather than a generic `string`:',
      reasoning: 'The revision clarifies the specific problem being addressed and the outcome of the fix, enhancing comprehension.',
      confidence: 0.9
    },
    {
      existing_text: 'Using `as const` is an incredibly effective pattern found in a multitude of applications, especially when configuring objects in TypeScript.',
      proposed_replacement: 'Using `as const` is a highly effective technique used in many applications, particularly for configuring objects in TypeScript.',
      reasoning: 'The revision simplifies the language and makes the statement more concise, improving readability.',
      confidence: 0.9
    }
  ]
}
```

#### Anthropic:
```typescript
[Error running Anthropic: SyntaxError: Expected ',' or '}' after property value in JSON at position 601]
```

#### Gemini:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'Here we have the same setup as before: a `modifyButton` function that takes in an object of `buttonAttributes` which expects a type of `ButtonAttributes` containing either "button", "submit" or "reset":',
      proposed_replacement: 'Let\'s explore a scenario involving a `modifyButton` function. This function accepts an object called `buttonAttributes`. The expected type for this object is `ButtonAttributes`, which can contain one of three values: "button", "submit", or "reset".',
      reasoning: 'The original sentence is quite technical and could be made more approachable by using simpler language and avoiding jargon.',
      confidence: 0.9
    },
    {
      existing_text: 'The problem arises when we try to pass `buttonAttributes` into the `modifyButton` function. We receive a TypeScript error stating that the argument of type `string` is not assignable to the parameter of type `ButtonAttributes`. This issue occurs because the `buttonAttributes.type` is mutable.',
      proposed_replacement: 'When we attempt to use `buttonAttributes` as an input for the `modifyButton` function, we encounter a TypeScript error. The error message indicates that the provided argument, which is of type `string`, cannot be assigned to the parameter expecting the `ButtonAttributes` type. This problem arises because the `type` property within `buttonAttributes` is mutable, meaning its value can be changed.',
      reasoning: 'The original sentence uses technical language that may not be familiar to all readers. Replacing it with simpler terms and providing a brief explanation of the error would improve clarity.',
      confidence: 0.95
    },
    {
      existing_text: 'Previously, we solved this by specifying a type for `buttonAttributes`.',
      proposed_replacement: 'In a previous example, we addressed this issue by explicitly defining the type for `buttonAttributes`.',
      reasoning: 'The original sentence assumes prior knowledge. Providing context and rephrasing it would make it more understandable for readers who may not be familiar with the previous example.',
      confidence: 0.85
    },
    {
      existing_text: "However, there's a more interesting approach where we can instruct TypeScript to treat `buttonAttributes` as if none of its properties can be changed. Essentially, we want to make `buttonAttributes` deeply read-only.",
      proposed_replacement: "However, there's an alternative and more intriguing method available. We can guide TypeScript to handle `buttonAttributes` as if its properties are fixed and cannot be altered. In essence, our goal is to make `buttonAttributes` entirely read-only, ensuring its properties remain unchanged.",
      reasoning: 'The original sentence uses technical language ("instruct TypeScript") that could be replaced with more common terms. Additionally, explaining the concept of "deeply read-only" would enhance understanding.',
      confidence: 0.9
    },
    {
      existing_text: "Your task is to find the appropriate annotation to apply to `buttonAttributes` to make it deeply read-only. However, you can only work on the `buttonAttributes` definition, and you're not allowed to use the `ButtonAttributes` type.",
      proposed_replacement: 'The challenge is to identify the correct annotation to apply to `buttonAttributes`, making it completely read-only. However, you are limited to modifying the definition of `buttonAttributes` itself and cannot utilize the `ButtonAttributes` type.',
      reasoning: 'Simplifying the language and avoiding technical jargon like "annotation" would make the instructions clearer.',
      confidence: 0.8
    },
    {
      existing_text: 'By adding `as const` to `buttonAttributes`, a `readonly` modifier is applied to the type.',
      proposed_replacement: 'By appending `as const` to the definition of `buttonAttributes`, we effectively apply a `readonly` modifier to its type.',
      reasoning: 'Rephrasing the sentence to explain the action and its effect would improve clarity.',
      confidence: 0.85
    },
    {
      existing_text: 'This fixes the inference issue on `type` so it will be inferred as a `button` and not a `string`:',
      proposed_replacement: 'This resolves the type inference problem, ensuring that `type` is correctly recognized as a `button` rather than a generic `string`:',
      reasoning: 'Using simpler language and explaining the outcome of the fix would enhance understanding.',
      confidence: 0.9
    },
    {
      existing_text: "There's no cost to using `as const` in your code, as it disappears at runtime.",
      proposed_replacement: "It's worth noting that using `as const` has no performance overhead, as it is removed during the runtime execution of your code.",
      reasoning: 'Rephrasing the sentence to emphasize the lack of performance impact would be beneficial for readers concerned about efficiency.',
      confidence: 0.75
    },
    {
      existing_text: 'Using `as const` is an incredibly effective pattern found in a multitude of applications, especially when configuring objects in TypeScript.',
      proposed_replacement: 'The `as const` pattern proves to be highly valuable in numerous scenarios, particularly when dealing with object configuration within TypeScript.',
      reasoning: 'Using less emphatic language and providing a specific use case would make the sentence more informative and less promotional.',
      confidence: 0.8
    }
  ]
}
```