---
title: Output of AccessibleLanguageNerd against 107-as-const-can-make-strings-infer-as-their-literals-in-objects.md
description: Generating proposed edits against a source text file using the AccessibleLanguageNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

There's another interesting feature of `as const`, which we'll see in this example.

The `modifyButton` function accepts an `attributes` object typed as `ButtonAttributes`, which has `type` values of "button," "submit," or "reset".


```typescript
type ButtonAttributes = {
  type: "button" | "submit" | "reset";
};

const modifyButton = (attributes: ButtonAttributes) => {};
```

In this example, the `buttonAttributes` object only defines `type` as "button," which causes an error when passing it into the `modifyButton` function:

```tsx
const buttonAttributes = {
  type: "button";
};

modifyButton(buttonAttributes); // red squiggly line under buttonAttributes
```

As we've seen, we can fix this by adding `as const` to the `buttonAttributes` object, which makes the entire object read-only:

```typescript
const buttonAttributes = {
  type: "button";
} as const;

// Hovering over buttonAttributes shows:
const buttonAttributes: {
  readonly type: "button";
}
```

We can also apply `as const` to just `type` property:

```typescript
const buttonAttributes = {
  type: "button" as const;
};
```

However, this time the `type` property here is not read-only, but it's inferred as its literal type:

```typescript
// Hovering over buttonAttributes shows:
const buttonAttributes: {
  type: "button";
}
```

Building on this, we could also ensure the literal type inference for various properties in an array of objects by adding `as const` after each `type` property:

```typescript
const modifyButtons = (attributes: ButtonAttributes[]) => {};

const buttonsToChange = [
  {
    type: "button" as const,
  },
  {
    type: "submit" as const,
  },
];
```

Even with `as const` applied, we're still able to modify the `type` property but only to be one of the allowed literal types:

```typescript
buttonAttributes.type = "button";
```

This property makes `as const` a handy tool to be used whenever you want to ensure a specific literal is inferred for an object you're working with.


### Operation Results:
This operation generated results by running the AccessibleLanguageNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  proposed_edits: [
    {
      existing_text: "which we'll see in this example.",
      proposed_replacement: 'as demonstrated in the following example.',
      reasoning: 'The proposed text is clearer and more formal, improving the flow of the introduction to the example.',
      confidence: 0.9
    },
    {
      existing_text: 'which causes an error when passing it into the `modifyButton` function:',
      proposed_replacement: 'which results in an error when it is passed to the `modifyButton` function:',
      reasoning: 'The revision clarifies the action and the subject, making the sentence easier to understand.',
      confidence: 0.95
    },
    {
      existing_text: "As we've seen, we can fix this by adding `as const` to the `buttonAttributes` object, which makes the entire object read-only:",
      proposed_replacement: 'To resolve this, we can add `as const` to the `buttonAttributes` object, making the entire object read-only:',
      reasoning: "The revision simplifies the sentence structure and uses 'resolve' instead of 'fix' for a more precise description of addressing the error.",
      confidence: 0.95
    },
    {
      existing_text: "However, this time the `type` property here is not read-only, but it's inferred as its literal type:",
      proposed_replacement: 'In this case, the `type` property is not read-only, but it is recognized specifically as its literal type:',
      reasoning: "The revision clarifies the explanation by using 'recognized specifically' which is more precise than 'inferred', making the technical detail clearer.",
      confidence: 0.9
    },
    {
      existing_text: "Even with `as const` applied, we're still able to modify the `type` property but only to be one of the allowed literal types:",
      proposed_replacement: 'Even with `as const` applied, modification of the `type` property is still possible, but only to one of the predefined literal types:',
      reasoning: 'The revision clarifies and formalizes the sentence, making the technical constraint clearer to the reader.',
      confidence: 0.95
    }
  ]
}
```

#### Anthropic:
```typescript
{
  proposed_edits: [
    {
      existing_text: "There's another interesting feature of `as const`, which we'll see in this example.",
      proposed_replacement: "Let's explore another useful feature of `as const` through this example.",
      reasoning: 'The proposed edit makes the introduction more engaging and conversational, inviting the reader to explore the feature together.',
      confidence: 0.8
    },
    {
      existing_text: 'In this example, the `buttonAttributes` object only defines `type` as "button," which causes an error when passing it into the `modifyButton` function:',
      proposed_replacement: 'In this example, the `buttonAttributes` object defines `type` as only "button". This causes an error when `buttonAttributes` is passed into the `modifyButton` function:',
      reasoning: 'The proposed edit clarifies the cause of the error more explicitly, making it easier for the reader to understand the issue.',
      confidence: 0.9
    },
    {
      existing_text: "As we've seen, we can fix this by adding `as const` to the `buttonAttributes` object, which makes the entire object read-only:",
      proposed_replacement: 'To fix this error, we can add `as const` to the `buttonAttributes` object. This makes the entire object read-only:',
      reasoning: 'The proposed edit directly states the solution to the error, making the fix clearer to the reader.',
      confidence: 0.95
    },
    {
      existing_text: "However, this time the `type` property here is not read-only, but it's inferred as its literal type:",
      proposed_replacement: "In this case, the `type` property is not read-only, but it's inferred as a literal type:",
      reasoning: 'The proposed edit simplifies the sentence structure and removes the unnecessary "however" transition, making the explanation more concise.',
      confidence: 0.85
    },
    {
      existing_text: 'Building on this, we could also ensure the literal type inference for various properties in an array of objects by adding `as const` after each `type` property:',
      proposed_replacement: 'We can also ensure literal type inference for multiple properties in an array of objects by adding `as const` after each `type` property:',
      reasoning: 'The proposed edit simplifies the sentence and removes the "building on this" phrase, making the explanation more direct and easier to understand.',
      confidence: 0.9
    },
    {
      existing_text: "This property makes `as const` a handy tool to be used whenever you want to ensure a specific literal is inferred for an object you're working with.",
      proposed_replacement: "This behavior makes `as const` a useful tool for ensuring specific literal types are inferred for objects you're working with.",
      reasoning: 'The proposed edit simplifies the sentence structure and replaces "handy" with "useful" for a more professional tone.',
      confidence: 0.8
    }
  ]
}
```

#### Gemini:
```typescript
{
  proposed_edits: [
    {
      existing_text: "There's another interesting feature of `as const`, which we'll see in this example.",
      proposed_replacement: "The `as const` feature also has another interesting use, which we'll explore in this example.",
      reasoning: 'Rephrased the sentence to start with the subject for better readability.',
      confidence: 0.8
    },
    {
      existing_text: 'The `modifyButton` function accepts an `attributes` object typed as `ButtonAttributes`, which has `type` values of "button," "submit," or "reset".',
      proposed_replacement: 'The `modifyButton` function takes an `attributes` object as input. This object is of type `ButtonAttributes`, which means its `type` property can have values of "button," "submit," or "reset".',
      reasoning: "Rephrased the sentence to improve clarity and avoid the technical term 'typed as'.",
      confidence: 0.9
    },
    {
      existing_text: "As we've seen, we can fix this by adding `as const` to the `buttonAttributes` object, which makes the entire object read-only:",
      proposed_replacement: 'As demonstrated earlier, we can resolve this issue by adding `as const` to the `buttonAttributes` object. This makes the entire object read-only, as shown below:',
      reasoning: "Replaced 'fix this' with a more descriptive phrase and added context for the code snippet.",
      confidence: 0.9
    },
    {
      existing_text: "However, this time the `type` property here is not read-only, but it's inferred as its literal type:",
      proposed_replacement: 'In this case, the `type` property is not read-only. However, it is inferred as its literal type, meaning it can only hold the specific value "button":',
      reasoning: "Clarified the meaning of 'inferred as its literal type' for better understanding.",
      confidence: 0.95
    },
    {
      existing_text: 'Building on this, we could also ensure the literal type inference for various properties in an array of objects by adding `as const` after each `type` property:',
      proposed_replacement: 'We can extend this concept to ensure literal type inference for properties within an array of objects. To achieve this, we add `as const` after each `type` property, as shown in the following example:',
      reasoning: 'Rephrased the sentence to improve clarity and flow, and added context for the code snippet.',
      confidence: 0.9
    },
    {
      existing_text: "This property makes `as const` a handy tool to be used whenever you want to ensure a specific literal is inferred for an object you're working with.",
      proposed_replacement: 'This characteristic makes `as const` a valuable tool when you need to guarantee that a specific literal value is inferred for an object you are using.',
      reasoning: "Replaced 'property' with 'characteristic' for better accuracy and used more formal language.",
      confidence: 0.8
    }
  ]
}
```