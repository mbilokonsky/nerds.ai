---
title: Output of AccessibleLanguageNerd against 103-readonly-arrays.md
description: Generating proposed edits against a source text file using the AccessibleLanguageNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
In this exercise, you'll be dealing with a function called `printNames`. This function accepts an array of `names` and prints each name to the console.

However, we want to add a special restriction to this function: it shouldn't be possible to mutate the array it receives. In other words, operations such as adding or changing an element in the array shouldn't be allowed:

```typescript
function printNames(names: string[]) {
  for (const name of names) {
    console.log(name);
  }

  // @ts-expect-error // red squiggly line
  names.push("John");

  // @ts-expect-error // red squiggly line
  names[0] = "Billy";
}
```

However, in the current implementation the `@ts-expect-error` directives show us that it's possible to mutate the array.

## Challenge

Your task is to determine what type should be assigned to the `names` parameter to ensure that the array cannot be mutated. There are two ways to solve this problem.

# Resolution
There are a couple of strategies for handling read-only arrays in TypeScript. Both are functionally identical, and your choice of which to use will ultimately come down to personal preference.

## Solution 1: Add the `readonly` Keyword

The first approach solution is to add the `readonly` keyword before the `string[]` array. It applies to the entire `string[]` array, converting it into a read-only array:

```typescript
function printNames(names: readonly string[]) {
  ...
}
```

With this setup, you can't call `.push()` or modify elements in the array. However, methods like `map()` and `reduce()` remain accessible since these create a copy of the array, and do not mutate the original.

## Solution 2: Use the `ReadonlyArray` Type Helper

Alternatively, TypeScript offers a type helper called `ReadonlyArray` that functions in the same way:

```typescript
function printNames(names: ReadonlyArray<string>) {
  ...
}
```

Regardless of which of these two methods you use, TypeScript will still display `readonly string[]` when hovering over the `names` parameter:

```typescript
// hovering over `names` shows:
(parameter) names: readonly string[]
```

No matter which syntax you prefer, both approaches are functionally identical. If you feel the need to choose one, it might be better to choose the `readonly string[]` syntax for consistency. Whichever you choose, remember they're essentially the same under the hood.

### Operation Results:
This operation generated results by running the AccessibleLanguageNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'The first approach solution is to add the `readonly` keyword before the `string[]` array.',
      proposed_replacement: 'The first solution is to add the `readonly` keyword before the `string[]` array.',
      reasoning: "The phrase 'approach solution' is redundant. Simplifying it to 'solution' makes the sentence clearer and more direct.",
      confidence: 1
    },
    {
      existing_text: "With this setup, you can't call `.push()` or modify elements in the array.",
      proposed_replacement: 'With this setup, you cannot use `.push()` to add elements or directly modify elements in the array.',
      reasoning: "Expanding 'can't' to 'cannot' and specifying the action of adding elements clarifies the restrictions imposed by the setup.",
      confidence: 0.9
    },
    {
      existing_text: 'However, methods like `map()` and `reduce()` remain accessible since these create a copy of the array, and do not mutate the original.',
      proposed_replacement: 'However, methods like `map()` and `reduce()` are still usable because they create a new copy of the array and do not change the original array.',
      reasoning: "Replacing 'accessible' with 'usable' and 'mutate' with 'change' simplifies the language and makes the explanation more accessible to readers who may not be familiar with technical jargon.",
      confidence: 0.9
    },
    {
      existing_text: 'Alternatively, TypeScript offers a type helper called `ReadonlyArray` that functions in the same way:',
      proposed_replacement: 'Alternatively, TypeScript provides a type helper named `ReadonlyArray` that works similarly:',
      reasoning: "Replacing 'offers' with 'provides' and 'functions in the same way' with 'works similarly' simplifies the language and enhances readability.",
      confidence: 0.9
    },
    {
      existing_text: 'No matter which syntax you prefer, both approaches are functionally identical.',
      proposed_replacement: 'Regardless of your preferred syntax, both methods achieve the same functionality.',
      reasoning: "Rephrasing for clarity and to avoid repetition of 'both' in close proximity.",
      confidence: 0.9
    }
  ]
}
```

#### Anthropic:
```typescript
{
  proposed_edits: [
    {
      existing_text: "In this exercise, you'll be dealing with a function called `printNames`. This function accepts an array of `names` and prints each name to the console.",
      proposed_replacement: "In this exercise, you'll work with a function called `printNames` that accepts an array of `names` and prints each name to the console.",
      reasoning: "The proposed edit simplifies the language while preserving the meaning. 'Dealing with' is replaced with the more straightforward 'work with'.",
      confidence: 0.8
    },
    {
      existing_text: "However, we want to add a special restriction to this function: it shouldn't be possible to mutate the array it receives. In other words, operations such as adding or changing an element in the array shouldn't be allowed:",
      proposed_replacement: 'We want to add a restriction to this function: it should not allow mutating the input array. This means operations like adding or changing array elements should not be permitted:',
      reasoning: "The proposed edit simplifies the language by breaking up a long sentence and using more direct phrasing like 'should not allow' instead of 'shouldn't be possible'.",
      confidence: 0.9
    },
    {
      existing_text: "However, in the current implementation the `@ts-expect-error` directives show us that it's possible to mutate the array.",
      proposed_replacement: 'However, the current implementation allows mutating the array, as shown by the `@ts-expect-error` directives.',
      reasoning: 'The proposed edit simplifies the sentence structure while preserving the meaning.',
      confidence: 0.8
    },
    {
      existing_text: 'Your task is to determine what type should be assigned to the `names` parameter to ensure that the array cannot be mutated. There are two ways to solve this problem.',
      proposed_replacement: 'Your task is to determine the type to assign to the `names` parameter to prevent array mutation. There are two ways to do this.',
      reasoning: "The proposed edit simplifies the language by using more direct phrasing like 'prevent array mutation' instead of 'ensure that the array cannot be mutated'.",
      confidence: 0.9
    },
    {
      existing_text: 'There are a couple of strategies for handling read-only arrays in TypeScript. Both are functionally identical, and your choice of which to use will ultimately come down to personal preference.',
      proposed_replacement: 'TypeScript provides two functionally identical strategies for handling read-only arrays. Your choice between them ultimately comes down to personal preference.',
      reasoning: 'The proposed edit simplifies the language by being more direct and concise.',
      confidence: 0.8
    },
    {
      existing_text: 'The first approach solution is to add the `readonly` keyword before the `string[]` array. It applies to the entire `string[]` array, converting it into a read-only array:',
      proposed_replacement: 'The first solution is to add the `readonly` keyword before the `string[]` array type. This converts the entire array to read-only:',
      reasoning: "The proposed edit simplifies the language by removing redundant phrasing and using 'solution' instead of 'approach solution'.",
      confidence: 0.9
    },
    {
      existing_text: "With this setup, you can't call `.push()` or modify elements in the array. However, methods like `map()` and `reduce()` remain accessible since these create a copy of the array, and do not mutate the original.",
      proposed_replacement: "With this setup, you can't call `.push()` or modify array elements. However, you can still use methods like `map()` and `reduce()` since they create a new array instead of mutating the original.",
      reasoning: 'The proposed edit simplifies the language and sentence structure while preserving the meaning.',
      confidence: 0.9
    }
  ]
}
```

#### Gemini:
```typescript
{
  proposed_edits: [
    {
      existing_text: "In this exercise, you'll be dealing with a function called `printNames`. This function accepts an array of `names` and prints each name to the console.",
      proposed_replacement: 'This exercise explores a function named `printNames` that takes an array of `names` and displays each name on the console.',
      reasoning: 'Rephrased the sentence to be more direct and easier to understand.',
      confidence: 0.9
    },
    {
      existing_text: "However, we want to add a special restriction to this function: it shouldn't be possible to mutate the array it receives. In other words, operations such as adding or changing an element in the array shouldn't be allowed:",
      proposed_replacement: 'We want to add a constraint to this function: it should not be possible to modify the array it receives. This means operations like adding or changing elements within the array should be prohibited:',
      reasoning: "Replaced 'mutate' with 'modify' for better clarity and used more common phrasing.",
      confidence: 0.9
    },
    {
      existing_text: 'Your task is to determine what type should be assigned to the `names` parameter to ensure that the array cannot be mutated.',
      proposed_replacement: 'Your objective is to identify the appropriate type for the `names` parameter to prevent any modifications to the array.',
      reasoning: 'Used simpler wording while maintaining the original meaning.',
      confidence: 0.95
    },
    {
      existing_text: 'There are a couple of strategies for handling read-only arrays in TypeScript.',
      proposed_replacement: 'TypeScript provides a couple of methods for managing read-only arrays.',
      reasoning: 'Rephrased the sentence to be more active and engaging.',
      confidence: 0.85
    },
    {
      existing_text: 'Both are functionally identical, and your choice of which to use will ultimately come down to personal preference.',
      proposed_replacement: 'Both methods achieve the same outcome, so the choice between them is a matter of personal preference.',
      reasoning: 'Simplified the sentence structure and wording.',
      confidence: 0.9
    },
    {
      existing_text: 'The first approach solution is to add the `readonly` keyword before the `string[]` array.',
      proposed_replacement: 'The first method involves adding the `readonly` keyword before the `string[]` array type.',
      reasoning: 'Clarified the description of the first solution.',
      confidence: 0.8
    },
    {
      existing_text: 'It applies to the entire `string[]` array, converting it into a read-only array:',
      proposed_replacement: 'This keyword applies to the entire `string[]` array, transforming it into a read-only array:',
      reasoning: 'Added a subject to the sentence for better clarity.',
      confidence: 0.8
    },
    {
      existing_text: "With this setup, you can't call `.push()` or modify elements in the array.",
      proposed_replacement: 'With this configuration, calling `.push()` or modifying elements within the array becomes impossible.',
      reasoning: 'Rephrased the sentence to be more direct and impactful.',
      confidence: 0.85
    },
    {
      existing_text: 'However, methods like `map()` and `reduce()` remain accessible since these create a copy of the array, and do not mutate the original.',
      proposed_replacement: 'However, methods such as `map()` and `reduce()` remain available as they create a new copy of the array without altering the original.',
      reasoning: 'Used more common wording and clarified the reason for the availability of these methods.',
      confidence: 0.9
    },
    {
      existing_text: 'Alternatively, TypeScript offers a type helper called `ReadonlyArray` that functions in the same way:',
      proposed_replacement: 'As an alternative, TypeScript provides a type helper named `ReadonlyArray` that serves the same purpose:',
      reasoning: 'Rephrased the sentence to be more direct and informative.',
      confidence: 0.85
    },
    {
      existing_text: 'No matter which syntax you prefer, both approaches are functionally identical.',
      proposed_replacement: 'Regardless of your preferred syntax, both methods achieve the same result.',
      reasoning: 'Simplified the sentence structure and wording.',
      confidence: 0.9
    },
    {
      existing_text: 'If you feel the need to choose one, it might be better to choose the `readonly string[]` syntax for consistency.',
      proposed_replacement: 'If you need to make a choice, opting for the `readonly string[]` syntax might be preferable for consistency.',
      reasoning: 'Rephrased the sentence to be more concise and direct.',
      confidence: 0.8
    },
    {
      existing_text: "Whichever you choose, remember they're essentially the same under the hood.",
      proposed_replacement: "Regardless of your choice, it's important to remember that both methods function identically.",
      reasoning: 'Rephrased the sentence to emphasize the functional equivalence of the two methods.',
      confidence: 0.9
    }
  ]
}
```