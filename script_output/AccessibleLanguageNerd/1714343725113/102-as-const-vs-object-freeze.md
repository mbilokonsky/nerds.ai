---
title: Output of AccessibleLanguageNerd against 102-as-const-vs-object-freeze.md
description: Generating proposed edits against a source text file using the AccessibleLanguageNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

# Problem
In our continued exploration of button types, we now have a modified version of `ButtonAttributes` that accepts `cancel` and `confirm` buttons. Each of these buttons exists as an object with a `type` of `ButtonType`. As in the previous exercises, the `ButtonType` remains either `button`, `submit`, or `reset`:

```tsx
type ButtonType = "button" | "submit" | "reset";

type ButtonAttributes = {
  cancel: {
    type: ButtonType;
  };
  confirm: {
    type: ButtonType;
  };
};
```

We call `Object.freeze()` on `buttonAttributes` which effectively locks the object, preventing any property alterations: 

```tsx
const modifyButtons = (attributes: ButtonAttributes) => {};

const buttonAttributes = Object.freeze({
  cancel: {
    type: "button",
  },
  confirm: {
    type: "button",
  },
});

modifyButtons(buttonAttributes); // red squiggly line under buttonAttributes
```

However, there's an error when we call `modifyButtons` with `buttonAttributes`.

## Challenge

Your task is to diagnose why we have an error when using `Object.freeze`, since it seems like it should work like `as const` did.

To solve the issue, you should only modify the `buttonAttributes` code.

# Resolution
In TypeScript, using `Object.freeze` is a common method for creating immutable objects. However, there are some significant differences between `Object.freeze` and `as const`.

When applying `Object.freeze` to the `buttonAttributes` object, we can see that a read-only modifier is being inferred on this object:

```typescript
type ButtonType = "button" | "submit" | "reset";

const buttonAttributes = Object.freeze({
  cancel: {
    type: "button" as ButtonType,
  },
  confirm: {
    type: "button" as ButtonType,
  },
});

// hovering over buttonAttributes shows:
const buttonAttributes: Readonly<{
  cancel: {
    type: "button";
  };
  confirm: {
    type: "button";
  };
}>
```

However, it's only working at the top level of the object. For example, if we add another type at the top level like `type: 'blah'`, the top level property is read-only. If we try to modify this, TypeScript will throw an error: 

```typescript
const buttonAttributes = Object.freeze({
  type: "blah",
  cancel: {
    type: "button" as ButtonType,
  },
  confirm: {
    type: "button" as ButtonType,
  },
});

buttonAttributes.type = "submit"; // red squiggly line under `type`

// Hovering over type shows:
Cannot assign to 'type' because it is a read-only property
```

However, `Object.freeze` doesn't work on nested levels of an object, so we can still modify the `type` property of `cancel` and `confirm`:

```typescript
buttonAttributes.confirm.type = "reset";
```

This behavior is because `Object.freeze` is not recursive; it only works on the top level of the object. Another thing to note about `Object.freeze` is that it runs at runtime, which can make your application slower.

An alternative to `Object.freeze` is using `as const`. When we modify `buttonAttributes` to use `as const` instead of `Object.freeze`, the whole object, including all nested layers, becomes read-only. Moreover, `as const` infers those literals too. 

```typescript
const buttonAttributes = {
  cancel: {
    type: "button" as ButtonType,
  },
  confirm: {
    type: "button" as ButtonType,
  },
} as const;

// Hovering over buttonAttributes shows:
const buttonAttributes: {
  readonly cancel: {
    readonly type: "button";
  };
  readonly confirm: {
    readonly type: "button";
  };
}
```

`As const` does not have any runtime cost and recurses through the object, which makes it preferable over `Object.freeze` unless you need to ensure freezing at runtime specifically. Overall, `as const` provides a more convenient and efficient approach to creating immutable objects in TypeScript than using `Object.freeze`.

### Operation Results:
This operation generated results by running the AccessibleLanguageNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'In our continued exploration of button types, we now have a modified version of `ButtonAttributes` that accepts `cancel` and `confirm` buttons.',
      proposed_replacement: "In our ongoing study of button types, we've updated the `ButtonAttributes` to include `cancel` and `confirm` buttons.",
      reasoning: 'Simplifies and clarifies the sentence structure for better readability.',
      confidence: 0.9
    },
    {
      existing_text: 'Each of these buttons exists as an object with a `type` of `ButtonType`.',
      proposed_replacement: 'Each button is represented as an object with a `type` property that can be `ButtonType`.',
      reasoning: 'Clarifies the description of how each button is structured within the object.',
      confidence: 0.9
    },
    {
      existing_text: 'We call `Object.freeze()` on `buttonAttributes` which effectively locks the object, preventing any property alterations:',
      proposed_replacement: 'We use `Object.freeze()` on `buttonAttributes` to lock the object, which prevents any changes to its properties:',
      reasoning: 'Rephrases for clarity and conciseness.',
      confidence: 0.9
    },
    {
      existing_text: 'Your task is to diagnose why we have an error when using `Object.freeze`, since it seems like it should work like `as const` did.',
      proposed_replacement: "Your task is to figure out why there's an error with `Object.freeze`, especially since it appears to function similarly to `as const`.",
      reasoning: 'Rewords for clarity and to make the sentence more direct.',
      confidence: 0.9
    },
    {
      existing_text: "However, it's only working at the top level of the object.",
      proposed_replacement: 'However, this only applies to the top level of the object.',
      reasoning: 'Clarifies the limitation of `Object.freeze` to the top level.',
      confidence: 0.9
    },
    {
      existing_text: 'This behavior is because `Object.freeze` is not recursive; it only works on the top level of the object.',
      proposed_replacement: 'This happens because `Object.freeze` is not recursiveâ€”it only affects the top level of the object.',
      reasoning: 'Clarifies the non-recursive nature of `Object.freeze` and its effect.',
      confidence: 0.9
    },
    {
      existing_text: 'Another thing to note about `Object.freeze` is that it runs at runtime, which can make your application slower.',
      proposed_replacement: "It's also important to note that `Object.freeze` operates at runtime, which can slow down your application.",
      reasoning: 'Rephrases for clarity and emphasis on the potential performance impact.',
      confidence: 0.9
    },
    {
      existing_text: '`As const` does not have any runtime cost and recurses through the object, which makes it preferable over `Object.freeze` unless you need to ensure freezing at runtime specifically.',
      proposed_replacement: '`As const` incurs no runtime cost and applies recursively through the object, making it generally preferable to `Object.freeze` unless runtime freezing is specifically required.',
      reasoning: 'Clarifies the advantages of `as const` over `Object.freeze` and the specific scenario where `Object.freeze` might be necessary.',
      confidence: 0.9
    }
  ]
}
```

#### Anthropic:
```typescript
[Error running Anthropic: SyntaxError: Expected property name or '}' in JSON at position 1]
```

#### Gemini:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'In our continued exploration of button types, we now have a modified version of `ButtonAttributes` that accepts `cancel` and `confirm` buttons. Each of these buttons exists as an object with a `type` of `ButtonType`. As in the previous exercises, the `ButtonType` remains either `button`, `submit`, or `reset`:',
      proposed_replacement: "Let's explore different button types by looking at a modified version of `ButtonAttributes` that includes `cancel` and `confirm` buttons. These buttons are represented as objects, each having a `type` property that corresponds to a `ButtonType`. Similar to previous examples, the `ButtonType` can be either `button`, `submit`, or `reset`:",
      reasoning: 'The original sentence is quite long and contains technical jargon that may not be familiar to all readers. The proposed revision simplifies the language and provides more context, making it easier to understand the purpose of the code.',
      confidence: 0.9
    },
    {
      existing_text: 'We call `Object.freeze()` on `buttonAttributes` which effectively locks the object, preventing any property alterations:',
      proposed_replacement: 'To prevent any changes to the `buttonAttributes` object, we use `Object.freeze()`. This makes the object immutable, meaning its properties cannot be modified.',
      reasoning: 'The original sentence uses technical terms like `Object.freeze()` and "property alterations" without explaining their meaning. The proposed revision clarifies the purpose of using `Object.freeze()` and explains the concept of immutability in simpler terms.',
      confidence: 0.95
    },
    {
      existing_text: 'Your task is to diagnose why we have an error when using `Object.freeze`, since it seems like it should work like `as const` did.',
      proposed_replacement: "Let's figure out why we're encountering an error when using `Object.freeze()`, especially since it appears similar to using `as const`.",
      reasoning: 'The original sentence is phrased as a direct instruction, which can sound overly formal. The proposed revision uses a more conversational tone and encourages the reader to participate in the problem-solving process.',
      confidence: 0.85
    },
    {
      existing_text: 'To solve the issue, you should only modify the `buttonAttributes` code.',
      proposed_replacement: 'To fix this problem, we only need to make changes to the `buttonAttributes` code.',
      reasoning: 'The original sentence uses the imperative mood, which can sound commanding. The proposed revision uses a more collaborative tone and suggests that the reader and the writer are working together to solve the problem.',
      confidence: 0.8
    },
    {
      existing_text: 'In TypeScript, using `Object.freeze` is a common method for creating immutable objects. However, there are some significant differences between `Object.freeze` and `as const`.',
      proposed_replacement: 'In TypeScript, both `Object.freeze` and `as const` can be used to create immutable objects, but they work in slightly different ways.',
      reasoning: 'The original sentence uses technical jargon and assumes the reader is familiar with the concepts of immutability and the differences between `Object.freeze` and `as const`. The proposed revision simplifies the language and provides a more general overview of the topic.',
      confidence: 0.9
    },
    {
      existing_text: 'When applying `Object.freeze` to the `buttonAttributes` object, we can see that a read-only modifier is being inferred on this object:',
      proposed_replacement: 'When we use `Object.freeze` on the `buttonAttributes` object, TypeScript infers that the object is read-only:',
      reasoning: 'The original sentence uses technical terms like "applying" and "inferred" which may not be familiar to all readers. The proposed revision uses simpler language and explains the concept of read-only in a more accessible way.',
      confidence: 0.95
    },
    {
      existing_text: "However, it's only working at the top level of the object. For example, if we add another type at the top level like `type: 'blah'`, the top level property is read-only. If we try to modify this, TypeScript will throw an error:",
      proposed_replacement: "However, `Object.freeze` only makes the top level of the object read-only. For instance, if we add a property like `type: 'blah'` to the top level, we won't be able to change its value. Trying to do so will result in a TypeScript error.",
      reasoning: 'The original sentence is quite long and contains technical jargon. The proposed revision breaks down the information into smaller chunks and uses simpler language to explain the behavior of `Object.freeze`.',
      confidence: 0.9
    },
    {
      existing_text: "However, `Object.freeze` doesn't work on nested levels of an object, so we can still modify the `type` property of `cancel` and `confirm`:",
      proposed_replacement: "However, `Object.freeze` doesn't affect nested properties within the object. This means we can still change the `type` property of `cancel` and `confirm`:",
      reasoning: 'The original sentence uses technical terms like "nested levels" which may not be clear to all readers. The proposed revision uses simpler language and explains the limitation of `Object.freeze` in a more accessible way.',
      confidence: 0.95
    },
    {
      existing_text: 'This behavior is because `Object.freeze` is not recursive; it only works on the top level of the object. Another thing to note about `Object.freeze` is that it runs at runtime, which can make your application slower.',
      proposed_replacement: "This is because `Object.freeze` only affects the top level of the object and doesn't apply to nested properties. Additionally, `Object.freeze` runs when the application is executed, which can potentially slow it down.",
      reasoning: 'The original sentence uses technical terms like "recursive" and "runtime" which may not be familiar to all readers. The proposed revision uses simpler language and explains the limitations of `Object.freeze` in a more accessible way.',
      confidence: 0.9
    },
    {
      existing_text: 'An alternative to `Object.freeze` is using `as const`. When we modify `buttonAttributes` to use `as const` instead of `Object.freeze`, the whole object, including all nested layers, becomes read-only. Moreover, `as const` infers those literals too.',
      proposed_replacement: 'Instead of using `Object.freeze`, we can use `as const`. This makes the entire `buttonAttributes` object read-only, including all its nested properties. Additionally, `as const` helps TypeScript understand the exact values of the properties.',
      reasoning: 'The original sentence uses technical terms like "nested layers" and "infers literals" which may not be clear to all readers. The proposed revision uses simpler language and explains the benefits of using `as const` in a more accessible way.',
      confidence: 0.95
    },
    {
      existing_text: '`As const` does not have any runtime cost and recurses through the object, which makes it preferable over `Object.freeze` unless you need to ensure freezing at runtime specifically. Overall, `as const` provides a more convenient and efficient approach to creating immutable objects in TypeScript than using `Object.freeze`.',
      proposed_replacement: "Using `as const` doesn't impact the application's performance and it makes all properties within the object read-only, making it a better choice than `Object.freeze` in most cases. However, if you specifically need to ensure immutability during runtime, `Object.freeze` might be necessary. Overall, `as const` offers a simpler and more efficient way to create immutable objects in TypeScript compared to `Object.freeze`.",
      reasoning: 'The original sentence uses technical terms like "runtime cost" and "recurses" which may not be clear to all readers. The proposed revision uses simpler language and explains the advantages of using `as const` in a more accessible way.',
      confidence: 0.9
    }
  ]
}
```