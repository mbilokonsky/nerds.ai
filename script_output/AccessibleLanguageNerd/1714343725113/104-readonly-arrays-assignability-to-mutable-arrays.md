---
title: Output of AccessibleLanguageNerd against 104-readonly-arrays-assignability-to-mutable-arrays.md
description: Generating proposed edits against a source text file using the AccessibleLanguageNerd nerd. The source text is included, followed by edits generated by the same nerd against three different LLMs.
---

When working with TypeScript, it's important to understand the distinction between read-only and mutable arrays.

In this example, `printNamesReadOnly` and `printNamesMutable`, which are functionally identical, except `printNamesReadOnly` takes a read-only array of names as a parameter whereas `printNamesMutable` takes a mutable array:

```typescript
function printNamesReadOnly(names: readonly string[]) {
  for (const name of names) {
    console.log(name);
  }
}

function printNamesMutable(names: string[]) {
  for (const name of names) {
    console.log(name);
  }
}
```

When we create a mutable array of names, it can be passed as an argument to both of these functions:

```typescript
const mutableNames = ["John", "Jane", "Mike"];

printNamesReadOnly(mutableNames);
printNamesMutable(mutableNames);
```

This works because specifying `readonly` on the `printNamesReadOnly` function parameter only guarantees that it won't alter the array's content. Thus, it doesn't matter if we pass a mutable array because it won't be changed.

However, the reverse isn't true.

If we declare a read-only array, which we often do using the `as const` syntax, we can only pass it to `printNamesReadOnly`. Attempting to pass it to `printNamesMutable` will yield an error:

```typescript
const readonlyNames = ["John", "Jane", "Mike"] as const;

printNamesReadOnly(readonlyNames);

printNamesMutable(readonlyNames); // red squiggly line under readonlyNames

// hovering over readonlyNames shows:
Error: Argument of type 'readonly ["John", "Jane", "Mike"]' is not assignable to parameter of type 'string[]'
```

The error arises due to the potential for a mutable array to be altered inside of the function, which isn't acceptable for a read-only array.

In essence, read-only arrays can only be assigned to other read-only types. This characteristic is somewhat viral: if a function deep down the call stack expects a `readonly` array, then that array must remain `readonly` throughout. Doing so ensures that the array won't be mutated in any manner as it moves down the stack.

In conclusion, even though you can assign mutable arrays to read-only arrays, you cannot assign read-only arrays to mutable arrays.

### Operation Results:
This operation generated results by running the AccessibleLanguageNerd nerd against the source text using three different LLMs. The results are as follows:

#### GPT:
```typescript
{
  proposed_edits: [
    {
      existing_text: 'which are functionally identical, except `printNamesReadOnly` takes a read-only array of names as a parameter whereas `printNamesMutable` takes a mutable array:',
      proposed_replacement: 'which function the same way. The difference is that `printNamesReadOnly` accepts a read-only array of names, while `printNamesMutable` accepts a mutable array:',
      reasoning: 'The revised text simplifies the sentence structure and clarifies the distinction between the two functions.',
      confidence: 0.95
    },
    {
      existing_text: "This works because specifying `readonly` on the `printNamesReadOnly` function parameter only guarantees that it won't alter the array's content. Thus, it doesn't matter if we pass a mutable array because it won't be changed.",
      proposed_replacement: "This is possible because the `readonly` specification on the `printNamesReadOnly` function's parameter ensures the function does not modify the array. Therefore, passing a mutable array is acceptable as the function guarantees no changes will be made to it.",
      reasoning: 'The revision clarifies the explanation and uses more formal language to enhance understanding.',
      confidence: 0.9
    },
    {
      existing_text: "The error arises due to the potential for a mutable array to be altered inside of the function, which isn't acceptable for a read-only array.",
      proposed_replacement: "This error occurs because there's a risk that the mutable array could be changed within the function, which is not allowed for a read-only array.",
      reasoning: 'The revision simplifies the sentence and makes the explanation more direct and easier to understand.',
      confidence: 0.95
    },
    {
      existing_text: 'This characteristic is somewhat viral: if a function deep down the call stack expects a `readonly` array, then that array must remain `readonly` throughout.',
      proposed_replacement: 'This characteristic spreads through the system: if a function deep in the call stack requires a `readonly` array, then the array must stay `readonly` at all levels.',
      reasoning: "The revision replaces 'somewhat viral' with a clearer description ('spreads through the system'), making the concept more accessible and less colloquial.",
      confidence: 0.9
    },
    {
      existing_text: 'In essence, read-only arrays can only be assigned to other read-only types.',
      proposed_replacement: 'Essentially, read-only arrays can only be assigned to other read-only types.',
      reasoning: "Adding 'Essentially' at the beginning of the sentence provides a smoother transition and emphasizes the summary nature of the statement.",
      confidence: 0.85
    }
  ]
}
```

#### Anthropic:
```typescript
{
  proposed_edits: [
    {
      existing_text: "When working with TypeScript, it's important to understand the distinction between read-only and mutable arrays.",
      proposed_replacement: "When working with TypeScript, it's crucial to grasp the difference between read-only and mutable arrays.",
      reasoning: "The word 'grasp' is more accessible than 'understand the distinction between'. It conveys the same meaning in a more straightforward way.",
      confidence: 0.8
    },
    {
      existing_text: 'In this example, `printNamesReadOnly` and `printNamesMutable`, which are functionally identical, except `printNamesReadOnly` takes a read-only array of names as a parameter whereas `printNamesMutable` takes a mutable array:',
      proposed_replacement: 'In this example, `printNamesReadOnly` and `printNamesMutable` are functionally identical, with one key difference: `printNamesReadOnly` accepts a read-only array of names as a parameter, while `printNamesMutable` accepts a mutable array:',
      reasoning: 'The original sentence is quite long and complex. Breaking it up and simplifying the language makes it easier to follow.',
      confidence: 0.9
    },
    {
      existing_text: "This works because specifying `readonly` on the `printNamesReadOnly` function parameter only guarantees that it won't alter the array's content. Thus, it doesn't matter if we pass a mutable array because it won't be changed.",
      proposed_replacement: "This works because specifying `readonly` on the `printNamesReadOnly` function parameter ensures that the function won't change the array's content. So even if we pass a mutable array, it's safe because the function promises not to modify it.",
      reasoning: "The proposed edit breaks up the long sentences and uses simpler language like 'ensures' instead of 'guarantees', and 'promises not to modify' instead of 'won't be changed'.",
      confidence: 0.85
    },
    {
      existing_text: "In essence, read-only arrays can only be assigned to other read-only types. This characteristic is somewhat viral: if a function deep down the call stack expects a `readonly` array, then that array must remain `readonly` throughout. Doing so ensures that the array won't be mutated in any manner as it moves down the stack.",
      proposed_replacement: "Essentially, read-only arrays can only be assigned to other read-only types. This property spreads through your code: if any function expects a `readonly` array, that array must stay `readonly` wherever it's used. This guarantees the array won't be changed accidentally as it's passed around.",
      reasoning: "The metaphorical language 'viral' and 'deep down the call stack' may be confusing. The edit rephrases these ideas in more literal terms. It also breaks up the long sentence for better readability.",
      confidence: 0.9
    }
  ]
}
```

#### Gemini:
```typescript
{
  proposed_edits: [
    {
      existing_text: "When working with TypeScript, it's important to understand the distinction between read-only and mutable arrays.",
      proposed_replacement: "In TypeScript, it's crucial to grasp the difference between arrays that can be modified (mutable) and those that cannot (read-only).",
      reasoning: 'The original sentence, while accurate, uses slightly more complex language than necessary. The proposed revision aims to simplify the language while maintaining the original meaning.',
      confidence: 0.9
    },
    {
      existing_text: "This works because specifying `readonly` on the `printNamesReadOnly` function parameter only guarantees that it won't alter the array's content.",
      proposed_replacement: "This is possible because marking the `printNamesReadOnly` function parameter as `readonly` simply ensures that the function itself won't modify the array's elements.",
      reasoning: "The original sentence uses the word 'guarantees', which might imply a stronger level of protection than 'readonly' actually provides. The proposed revision clarifies that the function itself won't modify the array, but doesn't prevent modifications elsewhere.",
      confidence: 0.8
    },
    {
      existing_text: "The error arises due to the potential for a mutable array to be altered inside of the function, which isn't acceptable for a read-only array.",
      proposed_replacement: 'The error occurs because a mutable array could potentially be changed within the function, which is not allowed for a read-only array.',
      reasoning: "The original sentence uses the phrase 'arises due to', which is slightly more formal than necessary. The proposed revision uses simpler language while maintaining the original meaning.",
      confidence: 0.9
    },
    {
      existing_text: 'This characteristic is somewhat viral: if a function deep down the call stack expects a `readonly` array, then that array must remain `readonly` throughout.',
      proposed_replacement: 'This behavior has a cascading effect: if a function further down in the call stack requires a `readonly` array, then the array must stay `readonly` all the way through. ',
      reasoning: "The term 'viral' might be confusing in this context. The proposed revision uses the phrase 'cascading effect' to better illustrate the concept of the requirement being passed down the call stack.",
      confidence: 0.8
    }
  ]
}
```